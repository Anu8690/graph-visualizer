{"version":3,"sources":["PathfindingVisualizer/Node/Node.js","PathfindingVisualizer/Algorithms/dfs.js","PathfindingVisualizer/Algorithms/dijkstra.js","PathfindingVisualizer/Mazes/maze.js","PathfindingVisualizer/Mazes/weightMaze.js","Navbar.js","PathfindingVisualizer/Mazes/hSkewMaze.js","PathfindingVisualizer/Mazes/vSkewMaze.js","Data Structures/disjointSetItem.js","Data Structures/disjointSet.js","PathfindingVisualizer/Mazes/kruskalsMaze1.js","PathfindingVisualizer/Mazes/primsMaze.js","PathfindingVisualizer/PathfindingVisualizer.js","PathfindingVisualizer/Mazes/wallMaze.js","PathfindingVisualizer/Algorithms/bfs.js","Canvas/CanvasContext.js","Canvas/CanvasBoard.js","Canvas/Algorithms/bfs.js","Canvas/Algorithms/dfs.js","Canvas/Algorithms/dijkstra.js","Canvas/Algorithms/visitAllEdges.js","Canvas/Algorithms/kruskals.js","Canvas/Algorithms/prims.js","Canvas/Canvas.js","App.js","index.js"],"names":["Node","props","this","row","col","weight","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","extraClassName","id","className","React","Component","getChildren","node","grid","childElements","forEach","direction","childRow","childCol","length","child","isVisited","push","childNodes","childNode","costFromSource","parent","Math","min","extractMinIndex","dijkstraPQ","minNode","minNodeIndex","i","currentNode","createNode","finishNode","startNode","srow","scol","frow","fcol","isNode","Number","POSITIVE_INFINITY","removeWall","nodeA","nodeB","rowA","colA","rowB","colB","r","floor","c","maze","rowNum","colNum","newNode","initialGrid","dfsStack","random","pop","weightMaze","Navbar","onVisualizeClick","state","visualize","bfs","dfs","dijkstra","alert","toggleCanvas","bfsClick","setState","dfsClick","dijkstraClick","onWeightWallToggleClick","weightOrWall","weightWallToggle","isCanvas","clearGrid","resetGrid","mazify","hmazify","vmazify","kruskalMazify","primMazify","weightMazify","wallMazify","clearWallsandWeights","kruskalMST","primMST","mazeOptions","data-toggle","href","onClick","weightAndWallOption","addWeightOption","type","vChildElements","hChildElements","horizontalSkewMaze","random1","verticalSkewMaze","DisjointSetItem","value","keyCallback","children","isRoot","getRoot","rank","getRank","Object","values","parentItem","forceSettingParentChild","addChild","childItem","getKey","setParent","DisjointSet","items","itemValue","disjointSetItem","templateDisjointItem","requiredDisjointItem","valueA","valueB","rootKeyA","find","rootKeyB","Error","rootA","rootB","disjointSet","index","hWallSet","vWallSet","kruskalMaze","makeSet","random2","neighborNodeRight","neighborNodeLeft","inSameSet","union","splice","unionJoint","primMaze","edgeQueue","PathfindingVisualizer","navbarHeight","height","toggleIsRunning","isRunning","toggleWeightWallToggle","getInitialGrid","rowCount","ROW_COUNT","colCount","COLUMN_COUNT","currentRow","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","document","getElementById","onCellDown","mouseIsPressed","startNodePressed","finishNodePressed","onCellEnter","onCellLeave","onCellRelease","componentWillMount","documentElement","clientHeight","clientWidth","componentDidMount","console","log","hSkewMazify","vSkewMazify","wallMaze","algo","visitedNodesInOrder","minIndex","bfsQueue","childDirections","shift","x","y","nodesInShortestPathOrder","getNodesInShortestPathOrder","animate","setTimeout","animateShortestPath","nodeClassName","unshift","map","rowID","nodeID","CanvasContext","createContext","CanvasProvider","useState","isDrawing","setIsDrawing","nodeDrawing","setNodeDrawing","setIndex","canvasRef","useRef","contextRef","nodesOfGraph","pushNode","squareDistance","pow","centerX","centerY","setStartNode","currentCoordinates","whichNode","writeText","info","style","canvas","current","ctx","getContext","text","fontSize","fontFamily","color","textAlign","textBaseline","beginPath","font","fillStyle","fillText","stroke","currentEdgeWeight","setCurrentEdgeWeight","Provider","prepareCanvas","width","context","lineCap","strokeStyle","lineWidth","startDrawing","nativeEvent","offsetX","offsetY","prevIndex","arc","PI","closePath","start","moveTo","finishDrawing","end","lineTo","clearCanvas","fillRect","draw","toggleNodeDrawing","CanvasBoard","useContext","useEffect","settingStartNode","settingEndNode","endNode","setEndNode","settingGraph","emptyGraphCall","toggleEmptyTheGraph","setWeight","edgeWeightInput","onChange","event","parseInt","target","class","placeholder","startIndex","endIndex","onMouseMove","ref","graph","visitedEdgesInOrder","xB","yB","xA","yA","createEdge","childObject","compare","edgeA","edgeB","edgeWeight","getEdgeWeight","Canvas","graphOfNodes","redrawGraph","edge","visitAllEdges","fill","shortestPathNodes","visualizeMST","MSTedges","graphEdges","sort","kruskalSelectedEdges","kruskalsMST","primSelectedEdges","graphEdgesQueue","primsMST","animateMST","canvasOrGrid","visitedNodesInOrder1","visitedEdgesInOrder1","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.6139c019.chunk.js","sourcesContent":["import React from 'react';\r\nimport './Node.css'\r\nclass Node extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n    render() {\r\n        const {\r\n            row,\r\n            col,\r\n            weight,\r\n            isFinish,\r\n            isStart,\r\n            isWall,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            onMouseLeave,\r\n        } = this.props;\r\n        const extraClassName = isFinish ? \"node-finish\" : isStart ? \"node-start\" : isWall ? \"node-wall\" : \"\";\r\n        return (\r\n            <td\r\n                id={`node-${row}-${col}`}\r\n                className={`node ${extraClassName}`}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp()}\r\n                onMouseLeave={() => onMouseLeave(row,col)}\r\n            ><small>{weight === 1 ? \"\" : weight}</small></td> // It is used to create the grid.\r\n        );\r\n    }\r\n}\r\nexport default Node;","// DFS\r\n\r\nfunction getChildren(node, grid) {\r\n    const { row, col } = node;\r\n    const childElements = [];\r\n    const childDirections = [[1, 0], [0, 1], [-1, 0], [0, -1]];\r\n\r\n    childDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited && !child.isWall) {\r\n                // child.isVisited = true;\r\n                childElements.push(child);\r\n            }\r\n        }\r\n    })\r\n\r\n    return childElements;\r\n}\r\n\r\n\r\nexport function dfs(grid,startNode,finishNode){\r\n    const visitedNodesInOrder = [startNode];\r\n    startNode.isVisited= true;\r\n    let currentNode = startNode;\r\n    let dfsStack = [currentNode];\r\n    while (dfsStack.length) {\r\n        if(currentNode.isFinish) return visitedNodesInOrder;\r\n        const childElements = getChildren(currentNode, grid);\r\n        if (childElements.length) {\r\n            childElements[0].parent = currentNode;\r\n            currentNode = childElements[0];\r\n            currentNode.isVisited = true;\r\n            visitedNodesInOrder.push(currentNode);\r\n            dfsStack.push(currentNode);\r\n        }\r\n        else { \r\n            dfsStack.pop();\r\n            currentNode = dfsStack[dfsStack.length-1];\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n","// Dijkstra\r\n\r\nfunction getChildren (grid,node){\r\n    const childDirections = [[1,0],[0,1],[-1,0],[0,-1]];\r\n    const childNodes = [];\r\n    const {row,col} = node;\r\n    childDirections.forEach(direction=>{\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n\r\n        if(childRow >=0&& childCol>=0 && childCol<grid[0].length && childRow<grid.length)\r\n        {\r\n            const childNode = grid[childRow][childCol];\r\n            if(!childNode.isVisited && !childNode.isWall)\r\n            {\r\n                childNodes.push(childNode);\r\n                if(childNode.costFromSource > node.costFromSource + childNode.weight)\r\n                {\r\n                    childNode.parent = node;\r\n                }\r\n                childNode.costFromSource = Math.min(childNode.costFromSource, node.costFromSource + childNode.weight);\r\n            }\r\n            else if(childNode.isVisited)\r\n            {\r\n                if (childNode.costFromSource > node.costFromSource + childNode.weight) {\r\n                    childNode.parent = node;\r\n                }\r\n                childNode.costFromSource = Math.min(childNode.costFromSource, node.costFromSource + childNode.weight);\r\n                // console.log(\"parent = \",row,col,childNode.costFromSource)\r\n            }\r\n        }\r\n    })\r\n    return childNodes;\r\n}\r\n\r\nfunction extractMinIndex (dijkstraPQ){\r\n    let minNode = dijkstraPQ[0];\r\n    let minNodeIndex=0;\r\n    for(let i=1;i<dijkstraPQ.length;i++)\r\n    {\r\n        let currentNode = dijkstraPQ[i];\r\n        if(minNode.costFromSource > currentNode.costFromSource)\r\n        {\r\n            minNode = currentNode;\r\n            minNodeIndex = i;\r\n        }\r\n    }\r\n    return minNodeIndex;\r\n}\r\n\r\nexport function dijkstra(grid,startNode,finishNode){\r\n    const visitedNodesInOrder = [];\r\n\r\n    let currentNode;\r\n    let dijkstraPQ = [startNode];\r\n    startNode.isVisited=true;\r\n    while(dijkstraPQ.length)\r\n    {\r\n\r\n        const minIndex = extractMinIndex(dijkstraPQ);\r\n        currentNode = dijkstraPQ[minIndex];\r\n        if(currentNode.isFinish) return visitedNodesInOrder;\r\n\r\n        visitedNodesInOrder.push(currentNode);\r\n        const childNodes = getChildren(grid,currentNode);\r\n        childNodes.forEach(node => {\r\n            dijkstraPQ.push(node);\r\n            node.isVisited=true;\r\n        });\r\n        dijkstraPQ.splice(minIndex,1);\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\n","function createNode (row,col,finishNode,startNode){\r\n    const srow = startNode.row;\r\n    const scol = startNode.col;\r\n    const frow = finishNode.row;\r\n    const fcol = finishNode.col;\r\n    return {\r\n        row : row,\r\n        col : col,\r\n        isVisited : false,\r\n        isWall : false,\r\n        parent: null,\r\n        isNode: true,\r\n        isStart:\r\n            row === srow && col === scol,\r\n        isFinish:\r\n            row === frow && col === fcol,\r\n        weight :1,\r\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\r\n    };\r\n}\r\n\r\n// assumed rowNum ans colNum are odd\r\n\r\nfunction initialGrid (rowNum,colNum,startNode,finishNode){\r\n    const grid = [];\r\n    for(let r = 0;r<rowNum;r++)\r\n    {\r\n        const row = [];\r\n        for(let c = 0; c<colNum;c++)\r\n        {\r\n            const newNode = createNode(r,c,finishNode,startNode);\r\n            if((r%2==0 || c%2==0 )) newNode.isWall = true;\r\n            if(newNode.isFinish || newNode.isStart) newNode.isWall = false;\r\n            row.push(newNode);\r\n        }\r\n        grid.push(row);\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction getChildren (node,grid){\r\n    const {row,col} = node;\r\n    const childElements = [];\r\n    const childDirections = [[2,0],[0,2],[-2,0],[0,-2]];\r\n    \r\n    childDirections.forEach(direction=>{\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if(childRow>=0 && childCol >=0 && childRow < grid.length && childCol < grid[0].length)\r\n        {\r\n            const child = grid[childRow][childCol];\r\n            if(!child.isVisited)\r\n            {\r\n                // child.isVisited = true;\r\n                childElements.push(child);\r\n            }\r\n        }\r\n    })\r\n\r\n    return childElements;\r\n}\r\n\r\nfunction removeWall(nodeA,nodeB,grid){\r\n    \r\n    const rowA = nodeA.row;\r\n    const colA = nodeA.col;\r\n    const rowB = nodeB.row;\r\n    const colB = nodeB.col;\r\n\r\n    const r = Math.floor((rowA+rowB)/2);\r\n    const c = Math.floor((colA+colB)/2);\r\n\r\n    grid[r][c].isWall = false;\r\n    return;\r\n}\r\n\r\nexport function maze(rowNum,colNum,startNode,finishNode){\r\n    const grid = initialGrid(rowNum,colNum,startNode,finishNode);\r\n    // console.log(grid);\r\n    \r\n    let currentNode = grid[1][1];\r\n    let dfsStack = [currentNode];\r\n\r\n    while(dfsStack.length)\r\n    {\r\n        const childElements = getChildren(currentNode,grid);\r\n        if(childElements.length)\r\n        {\r\n            const random = Math.floor(Math.random() * childElements.length);\r\n            // console.log(currentNode, childElements[random], removeWall(currentNode, childElements[random]));\r\n            removeWall(currentNode,childElements[random],grid);\r\n            currentNode = childElements[random];\r\n            currentNode.isVisited = true;\r\n            dfsStack.push(currentNode);\r\n        }\r\n        else\r\n        {\r\n            currentNode = dfsStack.pop();\r\n        }\r\n        // console.log(currentNode);\r\n    }\r\n    grid.forEach(row=>{\r\n        row.forEach(node => {\r\n            node.isVisited = false;\r\n        });\r\n    });\r\n    // console.log(grid);\r\n    return grid;\r\n}\r\n\r\n","function distribution(){\r\n    const random1 = Math.random();\r\n    if(random1 <0.5)\r\n    {\r\n        const random2 = Math.floor(Math.random()*10 + 1);\r\n        return random2;\r\n    }\r\n    return 1;\r\n}\r\nexport function weightMaze(grid){\r\n    grid.forEach(row=>{\r\n        row.forEach(node =>{\r\n            if(!node.isWall){\r\n                node.weight = distribution();\r\n            }\r\n        });\r\n    });\r\n    return grid;\r\n}","import React from 'react';\r\nclass Navbar extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            visualize: '',\r\n            weightOrWall: false,\r\n            isCanvas: this.props.isCanvas,\r\n        }\r\n    }\r\n    onVisualizeClick = () => {\r\n        const visualize = this.state.visualize;\r\n        switch (visualize) {\r\n            case 'BFS':\r\n                this.props.bfs();\r\n                break;\r\n            case 'DFS':\r\n                this.props.dfs();\r\n                break;\r\n            case 'Dijkstra':\r\n                this.props.dijkstra();\r\n                break;\r\n            default:\r\n                alert('Choose an algorithm for visualization!!');\r\n        }\r\n    }\r\n    toggleCanvas = () => {\r\n        this.props.toggleCanvas();\r\n    }\r\n    bfsClick = () => {\r\n        this.setState({ visualize: 'BFS' });\r\n    }\r\n    dfsClick = () => {\r\n        this.setState({ visualize: 'DFS' });\r\n    }\r\n    dijkstraClick = () => {\r\n        this.setState({ visualize: 'Dijkstra' });\r\n    }\r\n    onWeightWallToggleClick = () => {\r\n        const weightOrWall = !this.state.weightOrWall;\r\n        this.setState({ weightOrWall });\r\n        this.props.weightWallToggle();\r\n    }\r\n    render() {\r\n        const {\r\n            clearGrid,\r\n            resetGrid,\r\n            mazify,\r\n            hmazify,\r\n            vmazify,\r\n            kruskalMazify,\r\n            primMazify,\r\n            weightMazify,\r\n            wallMazify,\r\n            clearWallsandWeights,\r\n            kruskalMST,\r\n            primMST,\r\n        } = this.props;\r\n\r\n        let mazeOptions = <li className=\"dropdown\">\r\n            <a className=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Mazes &amp; Patterns\r\n             <span className=\"caret\"></span></a>\r\n            <ul className=\"dropdown-menu\">\r\n                <li id='startButtonCreateMazeTwo'><a href=\"#\" onClick={mazify}>Recursive Division</a></li>\r\n                <li id='startButtonCreateMazeThree'><a href=\"#\" onClick={vmazify}>Recursive Division (vertical skew)</a></li>\r\n                <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={hmazify}>Recursive Division (horizontal skew)</a></li>\r\n                <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={kruskalMazify}>Kruskal's Maze</a></li>\r\n                <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={primMazify}>Prims's Maze</a></li>\r\n                <li id='startButtonCreateMazeOne'><a href=\"#\" onClick={wallMazify}>Basic Random Maze</a></li>\r\n                <li id='startButtonCreateMazeWeights'><a href=\"#\" onClick={weightMazify}>Basic Weight Maze</a></li>\r\n            </ul>\r\n        </li>;\r\n        let weightAndWallOption = <li id='startButtonClearWalls'><a href=\"#\" onClick={clearWallsandWeights}>Clear Walls &amp; Weights</a></li>;\r\n        let addWeightOption = <li id='startButtonAddObject'><a href=\"#\" onClick={this.onWeightWallToggleClick}>Add {this.state.weightOrWall ? 'Wall' : 'Weight'}</a></li>;\r\n        if(this.state.isCanvas){\r\n            mazeOptions = <li className=\"dropdown\">\r\n                <a className=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Minimum Spanning Tree\r\n             <span className=\"caret\"></span></a>\r\n                <ul className=\"dropdown-menu\">\r\n                    <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={kruskalMST}>Kruskal's Algorithm</a></li>\r\n                    <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={primMST}>Prims's Algorithm</a></li>\r\n                </ul>\r\n            </li>;\r\n            weightAndWallOption = <li></li>;\r\n            addWeightOption = <li></li>;\r\n        }\r\n\r\n        return (\r\n            <div id='navbarDiv'>\r\n                <nav className=\"navbar navbar-inverse\">\r\n                    <div className=\"container-fluid\">\r\n                        <div className=\"navbar-header\">\r\n                            <a id=\"refreshButton\" className=\"navbar-brand\" href=\"#\">Graph Visualizer</a>\r\n                        </div>\r\n                        <ul className=\"nav navbar-nav\">\r\n                            <li className=\"dropdown\">\r\n                                <a className=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Algorithms\r\n             <span className=\"caret\"></span></a>\r\n                                <ul className=\"dropdown-menu\">\r\n                                    <li id='startButtonDijkstra'><a href=\"#\" onClick={this.dijkstraClick}>Dijkstra's Algorithm</a></li>\r\n                                    <li id='startButtonBFS'><a href=\"#\" onClick={this.bfsClick}>Breadth-first Search</a></li>\r\n                                    <li id='startButtonDFS'><a href=\"#\" onClick={this.dfsClick}>Depth-first Search</a></li>\r\n                                </ul>\r\n                            </li>\r\n                            {mazeOptions}\r\n                            {addWeightOption}\r\n                            <li id='startButtonStart'><button id=\"actualStartButton\" className=\"btn btn-default navbar-btn\" type=\"button\" onClick={this.onVisualizeClick}>Visualize {this.state.visualize}!</button></li>\r\n                            <li id='startButtonClearBoard'><a href=\"#\" onClick={resetGrid}>Clear Board</a></li>\r\n                            {weightAndWallOption}\r\n                            <li id='startButtonClearPath'><a href=\"#\" onClick={clearGrid}>Clear Path</a></li>\r\n                            <li id='startButtonAddObject'><a href=\"#\" onClick={this.toggleCanvas}>Switch to {this.state.isCanvas ? 'Grid' : 'Canvas'}</a></li>\r\n                        </ul>\r\n                    </div>\r\n                </nav>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Navbar;","function createNode(row, col, finishNode, startNode) {\r\n    const srow = startNode.row;\r\n    const scol = startNode.col;\r\n    const frow = finishNode.row;\r\n    const fcol = finishNode.col;\r\n    return {\r\n        row: row,\r\n        col: col,\r\n        isVisited: false,\r\n        isWall: false,\r\n        parent: null,\r\n        isNode: true,\r\n        isStart:\r\n            row === srow && col === scol,\r\n        isFinish:\r\n            row === frow && col === fcol,\r\n        weight: 1,\r\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\r\n    };\r\n}\r\n\r\n// assumed rowNum ans colNum are odd\r\n\r\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\r\n    const grid = [];\r\n    for (let r = 0; r < rowNum; r++) {\r\n        const row = [];\r\n        for (let c = 0; c < colNum; c++) {\r\n            const newNode = createNode(r, c, finishNode, startNode);\r\n            if ((r % 2 == 0 || c % 2 == 0)) newNode.isWall = true;\r\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\r\n            row.push(newNode);\r\n        }\r\n        grid.push(row);\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction getChildren(node, grid) {\r\n    const { row, col } = node;\r\n    const childElements = [];\r\n    const hChildDirections = [[2, 0], [-2, 0]];\r\n    const vChildDirections = [[0, 2], [0, -2]];\r\n    // const childDirections = [[2,0],[0,2],[-2,0],[0,-2]];\r\n\r\n    const vChildElements = [];\r\n    vChildDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited) {\r\n                // child.isVisited = true;\r\n                vChildElements.push(child);\r\n            }\r\n        }\r\n    });\r\n    childElements.push(vChildElements);\r\n\r\n    const hChildElements = [];\r\n    hChildDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited) {\r\n                // child.isVisited = true;\r\n                hChildElements.push(child);\r\n            }\r\n        }\r\n    });\r\n    childElements.push(hChildElements);\r\n\r\n    return childElements;\r\n}\r\n\r\nfunction removeWall(nodeA, nodeB, grid) {\r\n\r\n    const rowA = nodeA.row;\r\n    const colA = nodeA.col;\r\n    const rowB = nodeB.row;\r\n    const colB = nodeB.col;\r\n\r\n    const r = Math.floor((rowA + rowB) / 2);\r\n    const c = Math.floor((colA + colB) / 2);\r\n\r\n    grid[r][c].isWall = false;\r\n    return;\r\n    // return grid[r][c];\r\n\r\n}\r\n\r\nexport function horizontalSkewMaze(rowNum, colNum, startNode, finishNode) {\r\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\r\n    // console.log(grid);\r\n\r\n    let currentNode = grid[1][1];\r\n    let dfsStack = [currentNode];\r\n\r\n    while (dfsStack.length) {\r\n        const childElements = getChildren(currentNode, grid);\r\n        if (childElements[0].length || childElements[1].length) {\r\n            const random1 = Math.floor(Math.random() * 4);\r\n            if (random1 !== 3 && childElements[0].length) {\r\n                const random = Math.floor(Math.random() * childElements[0].length);\r\n                removeWall(currentNode, childElements[0][random], grid);\r\n                currentNode = childElements[0][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else if (random1 === 3 && childElements[1].length) {\r\n                const random = Math.floor(Math.random() * childElements[1].length);\r\n                removeWall(currentNode, childElements[1][random], grid);\r\n                currentNode = childElements[1][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else if (childElements[1].length) {\r\n                const random = Math.floor(Math.random() * childElements[1].length);\r\n                removeWall(currentNode, childElements[1][random], grid);\r\n                currentNode = childElements[1][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else {\r\n                const random = Math.floor(Math.random() * childElements[0].length);\r\n                // console.log(currentNode, childElements[random], removeWall(currentNode, childElements[random]));\r\n                removeWall(currentNode, childElements[0][random], grid);\r\n                currentNode = childElements[0][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n        }\r\n        else {\r\n            currentNode = dfsStack.pop();\r\n        }\r\n    }\r\n    grid.forEach(row => {\r\n        row.forEach(node => {\r\n            node.isVisited = false;\r\n        });\r\n    });\r\n    // console.log(grid);\r\n    return grid;\r\n}","function createNode(row, col, finishNode, startNode) {\r\n    const srow = startNode.row;\r\n    const scol = startNode.col;\r\n    const frow = finishNode.row;\r\n    const fcol = finishNode.col;\r\n    return {\r\n        row: row,\r\n        col: col,\r\n        isVisited: false,\r\n        isWall: false,\r\n        parent: null,\r\n        isNode: true,\r\n        isStart:\r\n            row === srow && col === scol,\r\n        isFinish:\r\n            row === frow && col === fcol,\r\n        weight: 1,\r\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\r\n    };\r\n}\r\n\r\n// assumed rowNum ans colNum are odd\r\n\r\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\r\n    const grid = [];\r\n    for (let r = 0; r < rowNum; r++) {\r\n        const row = [];\r\n        for (let c = 0; c < colNum; c++) {\r\n            const newNode = createNode(r, c, finishNode, startNode);\r\n            if ((r % 2 == 0 || c % 2 == 0)) newNode.isWall = true;\r\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\r\n            row.push(newNode);\r\n        }\r\n        grid.push(row);\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction getChildren(node, grid) {\r\n    const { row, col } = node;\r\n    const childElements = [];\r\n    const hChildDirections = [[2, 0], [-2, 0]];\r\n    const vChildDirections = [[0, 2], [0, -2]];\r\n    // const childDirections = [[2,0],[0,2],[-2,0],[0,-2]];\r\n\r\n    const hChildElements = [];\r\n    hChildDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited) {\r\n                // child.isVisited = true;\r\n                hChildElements.push(child);\r\n            }\r\n        }\r\n    });\r\n    childElements.push(hChildElements);\r\n\r\n    const vChildElements = [];\r\n    vChildDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited) {\r\n                // child.isVisited = true;\r\n                vChildElements.push(child);\r\n            }\r\n        }\r\n    });\r\n    childElements.push(vChildElements);\r\n    return childElements;\r\n}\r\n\r\nfunction removeWall(nodeA, nodeB, grid) {\r\n\r\n    const rowA = nodeA.row;\r\n    const colA = nodeA.col;\r\n    const rowB = nodeB.row;\r\n    const colB = nodeB.col;\r\n\r\n    const r = Math.floor((rowA + rowB) / 2);\r\n    const c = Math.floor((colA + colB) / 2);\r\n\r\n    grid[r][c].isWall = false;\r\n    return;\r\n    // return grid[r][c];\r\n\r\n}\r\n\r\nexport function verticalSkewMaze(rowNum, colNum, startNode, finishNode) {\r\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\r\n    // console.log(grid);\r\n\r\n    let currentNode = grid[1][1];\r\n    let dfsStack = [currentNode];\r\n\r\n    while (dfsStack.length) {\r\n        const childElements = getChildren(currentNode, grid);\r\n        if (childElements[0].length || childElements[1].length) {\r\n            const random1 = Math.floor(Math.random() * 4);\r\n            if (random1 !== 3 && childElements[0].length) {\r\n                const random = Math.floor(Math.random() * childElements[0].length);\r\n                removeWall(currentNode, childElements[0][random], grid);\r\n                currentNode = childElements[0][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else if (random1 === 3 && childElements[1].length) {\r\n                const random = Math.floor(Math.random() * childElements[1].length);\r\n                removeWall(currentNode, childElements[1][random], grid);\r\n                currentNode = childElements[1][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else if (childElements[1].length) {\r\n                const random = Math.floor(Math.random() * childElements[1].length);\r\n                removeWall(currentNode, childElements[1][random], grid);\r\n                currentNode = childElements[1][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else {\r\n                const random = Math.floor(Math.random() * childElements[0].length);\r\n                // console.log(currentNode, childElements[random], removeWall(currentNode, childElements[random]));\r\n                removeWall(currentNode, childElements[0][random], grid);\r\n                currentNode = childElements[0][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n        }\r\n        else {\r\n            currentNode = dfsStack.pop();\r\n        }\r\n    }\r\n    grid.forEach(row => {\r\n        row.forEach(node => {\r\n            node.isVisited = false;\r\n        });\r\n    });\r\n    // console.log(grid);\r\n    return grid;\r\n}\r\n\r\n","export default class DisjointSetItem {\r\n    /**\r\n     * @param {*} value\r\n     * @param {function(value: *)} [keyCallback]\r\n     */\r\n    constructor(value, keyCallback) {\r\n        this.value = value;\r\n        this.keyCallback = keyCallback;\r\n        /** @var {DisjointSetItem} this.parent */\r\n        this.parent = null;\r\n        this.children = {};\r\n    }\r\n\r\n    /**\r\n     * @return {*}\r\n     */\r\n    getKey() {\r\n        // Allow user to define custom key generator.\r\n        if (this.keyCallback) {\r\n            return this.keyCallback(this.value);\r\n        }\r\n\r\n        // Otherwise use value as a key by default.\r\n        return this.value;\r\n    }\r\n\r\n    /**\r\n     * @return {DisjointSetItem}\r\n     */\r\n    getRoot() {\r\n        return this.isRoot() ? this : this.parent.getRoot();\r\n    }\r\n\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    isRoot() {\r\n        return this.parent === null;\r\n    }\r\n\r\n    /**\r\n     * Rank basically means the number of all ancestors.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getRank() {\r\n        if (this.getChildren().length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        let rank = 0;\r\n\r\n        /** @var {DisjointSetItem} child */\r\n        this.getChildren().forEach((child) => {\r\n            // Count child itself.\r\n            rank += 1;\r\n\r\n            // Also add all children of current child.\r\n            rank += child.getRank();\r\n        });\r\n\r\n        return rank;\r\n    }\r\n\r\n    /**\r\n     * @return {DisjointSetItem[]}\r\n     */\r\n    getChildren() {\r\n        return Object.values(this.children);\r\n    }\r\n\r\n    /**\r\n     * @param {DisjointSetItem} parentItem\r\n     * @param {boolean} forceSettingParentChild\r\n     * @return {DisjointSetItem}\r\n     */\r\n    setParent(parentItem, forceSettingParentChild = true) {\r\n        this.parent = parentItem;\r\n        if (forceSettingParentChild) {\r\n            parentItem.addChild(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param {DisjointSetItem} childItem\r\n     * @return {DisjointSetItem}\r\n     */\r\n    addChild(childItem) {\r\n        this.children[childItem.getKey()] = childItem;\r\n        childItem.setParent(this, false);\r\n\r\n        return this;\r\n    }\r\n}","import DisjointSetItem from './disjointSetItem';\r\n\r\nexport default class DisjointSet {\r\n    /**\r\n     * @param {function(value: *)} [keyCallback]\r\n     */\r\n    constructor(keyCallback) {\r\n        this.keyCallback = keyCallback;\r\n        this.items = {};\r\n    }\r\n\r\n    /**\r\n     * @param {*} itemValue\r\n     * @return {DisjointSet}\r\n     */\r\n    makeSet(itemValue) {\r\n        const disjointSetItem = new DisjointSetItem(itemValue, this.keyCallback);\r\n\r\n        if (!this.items[disjointSetItem.getKey()]) {\r\n            // Add new item only in case if it not presented yet.\r\n            this.items[disjointSetItem.getKey()] = disjointSetItem;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Find set representation node.\r\n     *\r\n     * @param {*} itemValue\r\n     * @return {(string|null)}\r\n     */\r\n    find(itemValue) {\r\n        const templateDisjointItem = new DisjointSetItem(itemValue, this.keyCallback);\r\n\r\n        // Try to find item itself;\r\n        const requiredDisjointItem = this.items[templateDisjointItem.getKey()];\r\n\r\n        if (!requiredDisjointItem) {\r\n            return null;\r\n        }\r\n\r\n        return requiredDisjointItem.getRoot().getKey();\r\n    }\r\n\r\n    /**\r\n     * Union by rank.\r\n     *\r\n     * @param {*} valueA\r\n     * @param {*} valueB\r\n     * @return {DisjointSet}\r\n     */\r\n    union(valueA, valueB) {\r\n        const rootKeyA = this.find(valueA);\r\n        const rootKeyB = this.find(valueB);\r\n\r\n        if (rootKeyA === null || rootKeyB === null) {\r\n            throw new Error('One or two values are not in sets');\r\n        }\r\n\r\n        if (rootKeyA === rootKeyB) {\r\n            // In case if both elements are already in the same set then just return its key.\r\n            return this;\r\n        }\r\n\r\n        const rootA = this.items[rootKeyA];\r\n        const rootB = this.items[rootKeyB];\r\n\r\n        if (rootA.getRank() < rootB.getRank()) {\r\n            // If rootB's tree is bigger then make rootB to be a new root.\r\n            rootB.addChild(rootA);\r\n\r\n            return this;\r\n        }\r\n\r\n        // If rootA's tree is bigger then make rootA to be a new root.\r\n        rootA.addChild(rootB);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param {*} valueA\r\n     * @param {*} valueB\r\n     * @return {boolean}\r\n     */\r\n    inSameSet(valueA, valueB) {\r\n        const rootKeyA = this.find(valueA);\r\n        const rootKeyB = this.find(valueB);\r\n\r\n        if (rootKeyA === null || rootKeyB === null) {\r\n            throw new Error('One or two values are not in sets');\r\n        }\r\n\r\n        return rootKeyA === rootKeyB;\r\n    }\r\n}","// with data structure\r\n// working fine\r\nimport DisjointSet from '../../Data Structures/disjointSet';\r\nlet disjointSet = new DisjointSet((node)=>{\r\n    return node.index;\r\n});\r\nfunction createNode(row, col, finishNode, startNode) {\r\n    const srow = startNode.row;\r\n    const scol = startNode.col;\r\n    const frow = finishNode.row;\r\n    const fcol = finishNode.col;\r\n    return {\r\n        row: row,\r\n        col: col,\r\n        isVisited: false,\r\n        isWall: false,\r\n        parent: null,\r\n        isNode: true,\r\n        isStart:\r\n            row === srow && col === scol,\r\n        isFinish:\r\n            row === frow && col === fcol,\r\n        weight: 1,\r\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\r\n        index: -1,\r\n    };\r\n}\r\nlet hWallSet = [];\r\nlet vWallSet = [];\r\nlet rootNodeIndex = [];\r\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\r\n    disjointSet = new DisjointSet((node) => {\r\n        return node.index;\r\n    });\r\n    hWallSet = [];\r\n    vWallSet = [];\r\n    const grid = [];\r\n    let i = 0;\r\n    for (let r = 0; r < rowNum; r++) {\r\n        const row = [];\r\n        for (let c = 0; c < colNum; c++) {\r\n            const newNode = createNode(r, c, finishNode, startNode);\r\n            if ((r % 2 == 0 || c % 2 == 0)) {\r\n                newNode.isWall = true;\r\n                if (c % 2 === 0 && r % 2 === 1 && c > 0 && c < colNum - 1) {\r\n                    hWallSet.push(newNode);\r\n                }\r\n                else if (r % 2 === 0 && c % 2 === 1 && r > 0 && r < rowNum - 1) {\r\n                    vWallSet.push(newNode);\r\n                }\r\n            }\r\n            else {\r\n                newNode.index = i;\r\n                // rootNodeIndex.push(i);\r\n                i++;\r\n                disjointSet.makeSet(newNode);\r\n            }\r\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\r\n            row.push(newNode);\r\n        }\r\n        grid.push(row);\r\n    }\r\n    return grid;\r\n}\r\nexport function kruskalMaze(rowNum, colNum, startNode, finishNode) {\r\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\r\n    // console.log(hWallSet.length);\r\n    // console.log(vWallSet.length);\r\n    while(hWallSet.length || vWallSet.length) {\r\n        const random1 = Math.floor(Math.random() * 2);\r\n        if (random1 && hWallSet.length) {\r\n            const random2 = Math.floor(Math.random() * hWallSet.length);\r\n            const node = hWallSet[random2];\r\n            const { row, col } = node;\r\n            const neighborNodeRight = grid[row][col + 1];\r\n            const neighborNodeLeft = grid[row][col - 1];\r\n            if (!disjointSet.inSameSet(neighborNodeLeft,neighborNodeRight)) {\r\n                node.isWall = false;\r\n                disjointSet.union(neighborNodeLeft,neighborNodeRight);\r\n            }\r\n            hWallSet.splice(random2, 1);\r\n        }\r\n        else if (!random1 && vWallSet.length) {\r\n            const random2 = Math.floor(Math.random() * vWallSet.length);\r\n            const node = vWallSet[random2];\r\n            const { row, col } = node;\r\n            const neighborNodeRight = grid[row + 1][col];\r\n            const neighborNodeLeft = grid[row - 1][col];\r\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\r\n                node.isWall = false;\r\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\r\n            }\r\n            vWallSet.splice(random2, 1);\r\n        }\r\n        else if (hWallSet.length) {\r\n            const random2 = Math.floor(Math.random() * hWallSet.length);\r\n            const node = hWallSet[random2];\r\n            const { row, col } = node;\r\n            const neighborNodeRight = grid[row][col + 1];\r\n            const neighborNodeLeft = grid[row][col - 1];\r\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\r\n                node.isWall = false;\r\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\r\n            }\r\n            hWallSet.splice(random2, 1);\r\n        }\r\n        else if (vWallSet.length) {\r\n            const random2 = Math.floor(Math.random() * vWallSet.length);\r\n            const node = vWallSet[random2];\r\n            const { row, col } = node;\r\n            const neighborNodeRight = grid[row + 1][col];\r\n            const neighborNodeLeft = grid[row - 1][col];\r\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\r\n                node.isWall = false;\r\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\r\n            }\r\n            vWallSet.splice(random2, 1);\r\n        }\r\n    }\r\n    // console.log(grid);\r\n    return grid;\r\n}","import DisjointSet from '../../Data Structures/disjointSet';\r\nlet disjointSet = new DisjointSet((node) => {\r\n    return node.index;\r\n});\r\n\r\nfunction createNode(row, col, finishNode, startNode) {\r\n    const srow = startNode.row;\r\n    const scol = startNode.col;\r\n    const frow = finishNode.row;\r\n    const fcol = finishNode.col;\r\n    return {\r\n        row: row,\r\n        col: col,\r\n        isVisited: false,\r\n        isWall: false,\r\n        parent: null,\r\n        isNode: true,\r\n        isStart:\r\n            row === srow && col === scol,\r\n        isFinish:\r\n            row === frow && col === fcol,\r\n        weight: 1,\r\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\r\n        index: -1,\r\n    };\r\n}\r\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\r\n    disjointSet = new DisjointSet((node) => {\r\n        return node.index;\r\n    });\r\n    const grid = [];\r\n    let i = 0;\r\n    for (let r = 0; r < rowNum; r++) {\r\n        const row = [];\r\n        for (let c = 0; c < colNum; c++) {\r\n            const newNode = createNode(r, c, finishNode, startNode);\r\n            if ((r % 2 == 0 || c % 2 == 0)) {\r\n                newNode.isWall = true;\r\n            }\r\n            else {\r\n                newNode.index = i;\r\n                i++;\r\n                disjointSet.makeSet(newNode);\r\n            }\r\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\r\n            row.push(newNode);\r\n        }\r\n        grid.push(row);\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction getChildren(node,grid) {\r\n    const childDirection = [[2,0],[0,2],[-2,0],[0,-2]];\r\n    const children = [];\r\n    const {row,col} = node;\r\n    childDirection.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if(childRow > 0 && childCol > 0 && childRow < grid.length && childCol < grid[0].length){\r\n            const childNode = grid[childRow][childCol];\r\n            children.push(childNode);            \r\n        }\r\n    });\r\n    return children;\r\n}\r\nfunction removeWall(nodeA, nodeB, grid) {\r\n\r\n    const rowA = nodeA.row;\r\n    const colA = nodeA.col;\r\n    const rowB = nodeB.row;\r\n    const colB = nodeB.col;\r\n\r\n    const r = Math.floor((rowA + rowB) / 2);\r\n    const c = Math.floor((colA + colB) / 2);\r\n\r\n    grid[r][c].isWall = false;\r\n    return;\r\n}\r\nfunction unionJoint(node,currentNode,grid){\r\n    const children = getChildren(node,grid);\r\n    children.forEach(child => {\r\n        if(disjointSet.inSameSet(child,currentNode) && !disjointSet.inSameSet(currentNode,node))\r\n        {\r\n            removeWall(child,node,grid);\r\n            disjointSet.union(currentNode, node);\r\n        }\r\n    });\r\n    return;\r\n}\r\nexport function primMaze(rowNum, colNum, startNode, finishNode) {\r\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\r\n\r\n    let currentNode = grid[1][1];\r\n    const edgeQueue= [grid[3][1],grid[1][3]];\r\n    grid[3][1].isVisited = true;\r\n    grid[1][3].isVisited = true;\r\n    while(edgeQueue.length)\r\n    {\r\n        const random = Math.floor(Math.random()*edgeQueue.length);\r\n        // removeWall(currentNode,edgeQueue[random],grid);\r\n        unionJoint(edgeQueue[random],currentNode,grid);\r\n        currentNode =  edgeQueue[random];\r\n        // console.log(currentNode);\r\n        const children = getChildren(currentNode,grid);\r\n        if(children.length){\r\n            children.forEach(child=>{\r\n                if(!child.isVisited){\r\n                    edgeQueue.push(child);\r\n                    child.isVisited = true;\r\n                }\r\n            });\r\n        }\r\n        edgeQueue.splice(random,1);\r\n    }\r\n    grid.forEach(row=>{\r\n        row.forEach(node=>{\r\n            node.isVisited = false;\r\n        });\r\n    });\r\n    return grid;\r\n}","import React from 'react';\r\nimport Node from './Node/Node';\r\nimport './PathfindingVisualizer.css'\r\nimport { bfs } from './Algorithms/bfs'\r\nimport { dfs } from './Algorithms/dfs'\r\nimport { dijkstra } from './Algorithms/dijkstra'\r\nimport { maze } from './Mazes/maze'\r\nimport { weightMaze } from './Mazes/weightMaze'\r\nimport { wallMaze } from './Mazes/wallMaze'\r\nimport Navbar from '../Navbar';\r\nimport {horizontalSkewMaze} from './Mazes/hSkewMaze';\r\nimport { verticalSkewMaze } from './Mazes/vSkewMaze';\r\nimport { kruskalMaze } from './Mazes/kruskalsMaze1';\r\nimport {primMaze} from './Mazes/primsMaze';\r\nclass PathfindingVisualizer extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            ROW_COUNT: 25,\r\n            COLUMN_COUNT: 35,\r\n            START_NODE_ROW: 5,\r\n            FINISH_NODE_ROW: 20,\r\n            START_NODE_COL: 5,\r\n            FINISH_NODE_COL: 30,\r\n            isRunning: false,\r\n            mouseIsPressed: false,\r\n            startNodePressed: false,\r\n            finishNodePressed: false,\r\n            navbarHeight: 0,\r\n            weightWallToggle:false,            \r\n        };\r\n\r\n    }\r\n\r\n    navbarHeight = (height) => {\r\n        const navbarHeight = height;\r\n        this.setState({ navbarHeight });\r\n    }\r\n\r\n    toggleIsRunning = () => {\r\n        let isRunning = !this.state.isRunning;\r\n        this.setState({ isRunning });\r\n    }\r\n    toggleWeightWallToggle = () =>{\r\n        const weightWallToggle = !this.state.weightWallToggle;\r\n        this.setState({weightWallToggle});\r\n    }\r\n\r\n    getInitialGrid = (\r\n        rowCount = this.state.ROW_COUNT,\r\n        colCount = this.state.COLUMN_COUNT,\r\n    ) => {\r\n        const initialGrid = [];\r\n        for (let row = 0; row < rowCount; row++) {\r\n            const currentRow = [];\r\n            for (let col = 0; col < colCount; col++) {\r\n                currentRow.push(this.createNode(row, col));\r\n            }\r\n            initialGrid.push(currentRow);\r\n        }\r\n        return initialGrid;\r\n    };\r\n\r\n    createNode = (row, col) => {\r\n        return {\r\n            row,\r\n            col,\r\n            isStart:\r\n                row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n            isFinish:\r\n                row === this.state.FINISH_NODE_ROW &&\r\n                col === this.state.FINISH_NODE_COL,\r\n            isVisited: false,\r\n            isWall: false,\r\n            parent: null,\r\n            isNode: true,\r\n            weight: 1,\r\n            costFromSource: (row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL) ? 0 : Number.POSITIVE_INFINITY,\r\n            // extraClassName:\"\",\r\n        };\r\n    };\r\n\r\n    clearGrid = () => {\r\n        if (!this.state.isRunning) {\r\n            let grid = this.state.grid;\r\n\r\n            for (const row of grid) {\r\n                for (const node of row) {\r\n                    if (!node.isStart && !node.isFinish && !node.isWall) {\r\n                        document.getElementById(\r\n                            `node-${node.row}-${node.col}`\r\n                        ).className = 'node';\r\n                        node.isVisited = false;\r\n                        node.parent = null;\r\n                        node.costFromSource = Number.POSITIVE_INFINITY;\r\n                        // nodeClassName = 'node';\r\n                    }\r\n                    else if (node.isStart || node.isFinish) {\r\n                        node.parent = null;\r\n                        node.isVisited = false;\r\n                        if(node.isStart) node.costFromSource = 0;\r\n                        else node.costFromSource = Number.POSITIVE_INFINITY;\r\n                    }\r\n                }\r\n            }\r\n            this.setState({ grid });\r\n            // console.log(grid);\r\n        }\r\n    }\r\n    clearWallsandWeights = () => {\r\n        if (!this.state.isRunning) {\r\n            let grid = this.state.grid;\r\n\r\n            for (const row of grid) {\r\n                for (const node of row) {\r\n                    if (node.isWall ) {\r\n                        document.getElementById(\r\n                            `node-${node.row}-${node.col}`\r\n                        ).className = 'node';\r\n                        node.isVisited = false;\r\n                        node.parent = null;\r\n                        node.isWall = false;\r\n                        node.costFromSource = Number.POSITIVE_INFINITY;\r\n                        // nodeClassName = 'node';\r\n                    }\r\n                    if (node.weight !==1)\r\n                    {\r\n                        node.weight = 1;\r\n                        node.costFromSource = node.isStart ? 0: Number.POSITIVE_INFINITY;\r\n                    }\r\n                }\r\n            }\r\n            this.setState({ grid });\r\n\r\n            // console.log(grid);\r\n        }\r\n    }\r\n    resetGrid = () => {\r\n        if (!this.state.isRunning) {\r\n            let grid = this.state.grid;\r\n\r\n            for (const row of grid) {\r\n                for (const node of row) {\r\n                    if (!node.isStart && !node.isFinish) {\r\n                        document.getElementById(\r\n                            `node-${node.row}-${node.col}`\r\n                        ).className = 'node';\r\n                        node.isVisited = false;\r\n                        node.parent = null;\r\n                        node.isWall = false;\r\n                        // nodeClassName = 'node';\r\n                    }\r\n                    else if (node.isStart || node.isFinish) {\r\n                        node.parent = null;\r\n                        node.isVisited = false;\r\n                    }\r\n                }\r\n            }\r\n            this.setState({ grid });\r\n            // console.log(grid);\r\n        }\r\n    }\r\n\r\n    onCellDown = (row, col) => {\r\n        if (!this.state.isRunning && !this.state.weightWallToggle) {\r\n\r\n            const grid = this.state.grid;\r\n            if (!this.state.mouseIsPressed) {\r\n                const mouseIsPressed = !this.state.mouseIsPressed;\r\n                this.setState({ mouseIsPressed });\r\n                const currentNode = grid[row][col];\r\n                if (!currentNode.isStart && !currentNode.isFinish) {\r\n                    if (currentNode.isWall) {\r\n                        document.getElementById(`node-${row}-${col}`).className = 'node';\r\n                        currentNode.isWall = false;\r\n                    }\r\n                    else {\r\n                        document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\r\n                        currentNode.isWall = true;\r\n                        currentNode.weight=1;\r\n                    }\r\n                }\r\n                else if (currentNode.isStart) {\r\n                    const startNodePressed = !this.state.startNodePressed;\r\n                    this.setState({ startNodePressed });\r\n                    document.getElementById(`node-${row}-${col}`).className = 'node';\r\n                    currentNode.isStart = false;\r\n                }\r\n                else if (currentNode.isFinish) {\r\n                    const finishNodePressed = !this.state.finishNodePressed;\r\n                    this.setState({ finishNodePressed });\r\n                    document.getElementById(`node-${row}-${col}`).className = 'node' ;\r\n                    currentNode.isFinish = false;\r\n                }\r\n            }\r\n        }\r\n        else if(!this.state.isRunning && this.state.weightWallToggle)\r\n        {\r\n            const grid = this.state.grid;\r\n            const currentNode = grid[row][col];\r\n            if(!currentNode.isWall){\r\n                currentNode.weight = currentNode.weight+1;\r\n            }\r\n        }\r\n    }\r\n    onCellEnter = (row, col) => {\r\n        if (!this.state.isRunning && this.state.mouseIsPressed) {\r\n            const grid = this.state.grid;\r\n            const currentNode = grid[row][col];\r\n            if (!currentNode.isStart && !currentNode.isFinish && !this.state.startNodePressed && !this.state.finishNodePressed) {\r\n                document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\r\n                currentNode.isWall = true;\r\n                currentNode.weight = 1;\r\n            }\r\n            else if (this.state.startNodePressed) {\r\n                const START_NODE_ROW = row;\r\n                const START_NODE_COL = col;\r\n                this.setState({ START_NODE_ROW, START_NODE_COL });\r\n                document.getElementById(`node-${row}-${col}`).className = 'node node-start';\r\n            }\r\n            else if (this.state.finishNodePressed) {\r\n                const FINISH_NODE_ROW = row;\r\n                const FINISH_NODE_COL = col;\r\n                this.setState({ FINISH_NODE_ROW, FINISH_NODE_COL });\r\n                document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\r\n            }\r\n\r\n        }\r\n    }\r\n    onCellLeave = (row, col) => {\r\n        const grid = this.state.grid;\r\n        if (this.state.startNodePressed) {\r\n            if (!grid[row][col].isFinish && !grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node';\r\n            else if (grid[row][col].isFinish) document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\r\n            else if (grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\r\n        }\r\n        else if (this.state.finishNodePressed) {\r\n            if (!grid[row][col].isStart && !grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node';\r\n            else if (grid[row][col].isStart) document.getElementById(`node-${row}-${col}`).className = 'node node-start';\r\n            else if (grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\r\n        }\r\n    }\r\n    onCellRelease = () => {\r\n        const mouseIsPressed = false;\r\n        const grid = this.state.grid;\r\n        if (this.state.startNodePressed) {\r\n            const row = this.state.START_NODE_ROW;\r\n            const col = this.state.START_NODE_COL;\r\n            document.getElementById(`node-${row}-${col}`).className = 'node node-start';\r\n            grid[row][col].isStart = true;\r\n            grid[row][col].isWall = false;\r\n        }\r\n        else if (this.state.finishNodePressed) {\r\n            const row = this.state.FINISH_NODE_ROW;\r\n            const col = this.state.FINISH_NODE_COL;\r\n            document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\r\n            grid[row][col].isFinish = true;\r\n            grid[row][col].isWall = false;\r\n        }\r\n        const startNodePressed = false;\r\n        const finishNodePressed = false;\r\n        this.setState({ mouseIsPressed, startNodePressed, finishNodePressed, grid });\r\n    }\r\n\r\n\r\n\r\n    componentWillMount = () => {\r\n        // console.log(\"required\", this.state.navbarHeight);\r\n        const ROW_COUNT = 2 * Math.floor(Math.floor((document.documentElement.clientHeight - this.state.navbarHeight) / 25) / 2) - 3;\r\n        const COLUMN_COUNT = 2 * Math.floor(Math.floor(document.documentElement.clientWidth / 25) / 2) - 1;\r\n        const START_NODE_ROW = Math.floor(ROW_COUNT / 2);\r\n        const FINISH_NODE_ROW = Math.floor(ROW_COUNT / 2);\r\n        const START_NODE_COL = Math.floor(COLUMN_COUNT / 4);\r\n        const FINISH_NODE_COL = Math.floor(3 * COLUMN_COUNT / 4);\r\n        this.setState({ ROW_COUNT, COLUMN_COUNT, START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL });\r\n    }\r\n    componentDidMount = () => {\r\n        const grid = this.getInitialGrid();\r\n        this.setState({ grid });\r\n        console.log(\"required\", this.state.navbarHeight);\r\n        // console.log(grid);\r\n    }\r\n\r\n\r\n\r\n    visualize(algo) {\r\n        if (!this.state.isRunning) {\r\n            this.clearGrid();\r\n            this.toggleIsRunning();\r\n            const { grid } = this.state;\r\n            const startNode =\r\n                grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n            const finishNode =\r\n                grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n            let visitedNodesInOrder;\r\n            switch (algo) {\r\n                case 'Dijkstra':\r\n                    visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n                    break;\r\n                // case 'AStar':\r\n                //     visitedNodesInOrder = AStar(grid, startNode, finishNode);\r\n                //     break;\r\n                case 'BFS':\r\n                    visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n                    break;\r\n                case 'DFS':\r\n                    visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n                    break;\r\n                default:\r\n                    // should never get here\r\n                    break;\r\n            }\r\n\r\n            // console.log(visitedNodesInOrder);\r\n            // console.log(grid);\r\n            const nodesInShortestPathOrder = this.getNodesInShortestPathOrder(finishNode);\r\n            nodesInShortestPathOrder.push('end');\r\n            this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n        }\r\n    }\r\n\r\n    animate(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if (i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    this.animateShortestPath(nodesInShortestPathOrder);\r\n                }, 2 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                const nodeClassName = document.getElementById(\r\n                    `node-${node.row}-${node.col}`,\r\n                ).className;\r\n                if (\r\n                    nodeClassName !== 'node node-start' &&\r\n                    nodeClassName !== 'node node-finish'\r\n                ) {\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = \r\n                        'node node-visited' ;\r\n                }\r\n            }, 2 * i);\r\n        }\r\n    }\r\n\r\n    /******************** Create path from start to finish ********************/\r\n    animateShortestPath(nodesInShortestPathOrder) {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n            if (nodesInShortestPathOrder[i] === 'end') {\r\n                setTimeout(() => {\r\n                    this.toggleIsRunning();\r\n                    // console.log(\"Completed\");\r\n                }, i * 50);\r\n            } else {\r\n                setTimeout(() => {\r\n                    const node = nodesInShortestPathOrder[i];\r\n                    const nodeClassName = document.getElementById(\r\n                        `node-${node.row}-${node.col}`,\r\n                    ).className;\r\n                    if (\r\n                        nodeClassName !== 'node node-start'&&\r\n                        nodeClassName !== 'node node-finish'\r\n                    ) {\r\n                        document.getElementById(`node-${node.row}-${node.col}`).className = \r\n                            'node node-shortest-path';\r\n                    }\r\n                }, i * 40);\r\n            }\r\n        }\r\n    }\r\n\r\n    getNodesInShortestPathOrder(finishNode) {\r\n        const nodesInShortestPathOrder = [];\r\n        let currentNode = finishNode;\r\n        while (currentNode !== null) {\r\n            nodesInShortestPathOrder.unshift(currentNode);\r\n            currentNode = currentNode.parent;\r\n        }\r\n        return nodesInShortestPathOrder;\r\n    }\r\n\r\n    mazify = () => {\r\n        if (!this.state.isRunning) {\r\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n            const grid = maze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\r\n            this.setState({ grid });\r\n        }\r\n    }\r\n    hSkewMazify = ()=>{\r\n        if(!this.state.isRunning){\r\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n            const grid = horizontalSkewMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\r\n            this.setState({ grid });\r\n        }\r\n    }\r\n    vSkewMazify = () => {\r\n        if (!this.state.isRunning) {\r\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n            const grid = verticalSkewMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\r\n            this.setState({ grid });\r\n        }\r\n    }\r\n    kruskalMazify = () =>{\r\n        if (!this.state.isRunning) {\r\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n            const grid = kruskalMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\r\n            this.setState({ grid });\r\n        }\r\n    }\r\n    primMazify = () => {\r\n        if (!this.state.isRunning) {\r\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n            const grid = primMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\r\n            this.setState({ grid });\r\n        }\r\n    }\r\n    weightMazify = ()=>{\r\n        let grid = this.state.grid;\r\n        grid = weightMaze(grid);\r\n        this.setState({grid});\r\n    }\r\n    wallMazify = ()=>{\r\n        let grid = this.state.grid;\r\n        grid = wallMaze(grid);\r\n        this.setState({ grid });\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <Navbar\r\n                    dfs={() => this.visualize('DFS')}\r\n                    bfs={() => this.visualize('BFS')}\r\n                    dijkstra={() => this.visualize('Dijkstra')}\r\n                    clearGrid={() => this.clearGrid()}\r\n                    resetGrid={() => this.resetGrid()}\r\n                    clearWallsandWeights={() => this.clearWallsandWeights()}\r\n                    mazify={() => this.mazify()}\r\n                    hmazify={() => this.hSkewMazify()}\r\n                    vmazify={() => this.vSkewMazify()}\r\n                    kruskalMazify={() => this.kruskalMazify()}\r\n                    primMazify={() => this.primMazify()}\r\n                    weightMazify={()=>this.weightMazify()}\r\n                    wallMazify={() => this.wallMazify()}\r\n                    navbarHeight={this.navbarHeight}\r\n                    weightWallToggle={()=>this.toggleWeightWallToggle()}\r\n                    toggleCanvas = {()=> this.props.toggleCanvas()}\r\n                    isCanvas={this.props.isCanvas}\r\n                ></Navbar>\r\n                <table className=\"center grid-container\" >\r\n                    <tbody className=\"grid\">\r\n                        {\r\n                            this.state.grid.map((row, rowID) => {\r\n                                return (\r\n                                    <tr key={rowID} >\r\n                                        {\r\n                                            row.map((node, nodeID) => {\r\n                                                const { row, col, isFinish, isStart, isWall, weight } = node;\r\n\r\n                                                return (\r\n                                                    <Node\r\n                                                        key={nodeID}\r\n                                                        row={row}\r\n                                                        col={col}\r\n                                                        weight={weight}\r\n                                                        isFinish={isFinish}\r\n                                                        isStart={isStart}\r\n                                                        isWall={isWall}\r\n                                                        onMouseDown={(x, y) => { this.onCellDown(x, y) }}\r\n                                                        onMouseEnter={(x, y) => this.onCellEnter(x, y)}\r\n                                                        onMouseUp={() => this.onCellRelease()}\r\n                                                        onMouseLeave={(x, y) => this.onCellLeave(x, y)}\r\n                                                    ></Node>\r\n                                                );\r\n                                            })\r\n                                        }\r\n\r\n                                    </tr>\r\n                                );\r\n                            })\r\n                        }\r\n                    </tbody>\r\n                </table>\r\n                {/* <button onClick={() => this.visualize('BFS')}>BFS</button>\r\n                <button onClick={() => this.visualize('DFS')}>DFS</button>\r\n                <button onClick={() => this.clearGrid()}>Clear Gridd</button>\r\n                <button onClick={() => this.resetGrid()}>Reset Grid</button>\r\n                <button onClick={() => this.mazify()}>Maze</button> */}\r\n\r\n            </div>\r\n        )\r\n    }\r\n\r\n}\r\n\r\nexport default PathfindingVisualizer;\r\n","export function wallMaze(grid) {\r\n    grid.forEach(row => {\r\n        row.forEach(node => {\r\n            if (!node.isWall && !node.isStart && !node.isFinish) {\r\n                const random = Math.floor(Math.random()*4);\r\n                if(random===0)\r\n                {\r\n                    node.isWall = true;\r\n                    node.weight = 1;\r\n                }\r\n            }\r\n        });\r\n    });\r\n    return grid;\r\n}","// BFS\r\n\r\nexport function bfs (grid,startNode,finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    let bfsQueue = [startNode];\r\n    startNode.isVisited = true;\r\n    const childDirections = [[1,0],[0,1],[-1,0],[0,-1]] ;\r\n\r\n    while(bfsQueue.length)\r\n    {\r\n        const currentNode = bfsQueue.shift();\r\n        if (currentNode === finishNode) return visitedNodesInOrder;\r\n        visitedNodesInOrder.push(currentNode);\r\n        const {row,col} = currentNode;\r\n\r\n        childDirections.forEach(direction => {\r\n            let x = row + direction[0];\r\n            let y = col + direction[1];\r\n\r\n            if(x>=0 && y>=0 && x<grid.length && y<grid[0].length && !grid[x][y].isWall && !grid[x][y].isVisited)\r\n            {\r\n                bfsQueue.push(grid[x][y]);\r\n                grid[x][y].isVisited = true;\r\n                grid[x][y].parent = currentNode;\r\n            }\r\n        });\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\n","import React, { useRef, useState } from \"react\";\r\n\r\nexport const CanvasContext = React.createContext();\r\n\r\nexport const CanvasProvider = ({ children }) => {\r\n    const [isDrawing, setIsDrawing] = useState(false);\r\n\r\n    const [nodeDrawing, setNodeDrawing] = useState(true);\r\n    const [index,setIndex] = useState(0);\r\n    const canvasRef = useRef(null);\r\n    const contextRef = useRef(null);\r\n\r\n    const prepareCanvas = (height, width) => {\r\n        const canvas = canvasRef.current\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        canvas.style.width = `${width}px`;\r\n        canvas.style.height = `${height}px`;\r\n\r\n        const context = canvas.getContext(\"2d\");\r\n        context.lineCap = \"round\";\r\n        context.strokeStyle = \"black\";\r\n        context.lineWidth = 1;\r\n        contextRef.current = context;\r\n    };\r\n\r\n    const toggleNodeDrawing = () => {\r\n        setNodeDrawing(!nodeDrawing);\r\n    }\r\n\r\n    const [nodesOfGraph, pushNode] = useState([]);\r\n\r\n    const squareDistance = (node, x, y) => {\r\n        return Math.pow(node.centerX - x, 2) + Math.pow(node.centerY - y, 2);\r\n    }\r\n\r\n    const [startNode, setStartNode] = useState(null);\r\n    let currentCoordinates = null;\r\n    const whichNode = (x, y) => {\r\n        let node = null;\r\n        for (let i = 0; i < nodesOfGraph.length; i++) {\r\n            if (squareDistance(nodesOfGraph[i], x, y) <= 1600) {\r\n                node = nodesOfGraph[i];\r\n                return node;\r\n            }\r\n        }\r\n        return node;\r\n    }\r\n\r\n    const writeText = (info, style = {}) => {\r\n        const canvas = canvasRef.current;\r\n        const ctx = canvas.getContext(\"2d\");\r\n        const { text, x, y } = info;\r\n        const { fontSize = 20, fontFamily = 'Arial', color = 'black', textAlign = 'left', textBaseline = 'top' } = style;\r\n\r\n        ctx.beginPath();\r\n        ctx.font = fontSize + 'px ' + fontFamily;\r\n        ctx.textAlign = textAlign;\r\n        ctx.textBaseline = textBaseline;\r\n        ctx.fillStyle = color;\r\n        ctx.fillText(text, x, y);\r\n        ctx.stroke();\r\n    }\r\n\r\n    const startDrawing = ({ nativeEvent }) => {\r\n        if (nodeDrawing) {\r\n            const { offsetX, offsetY } = nativeEvent;\r\n            if (whichNode(offsetX, offsetY)) return;\r\n\r\n            setIndex((prevIndex)=> prevIndex + 1);\r\n            const canvas = canvasRef.current;\r\n            const ctx = canvas.getContext(\"2d\");\r\n\r\n\r\n            ctx.beginPath();\r\n            ctx.arc(offsetX, offsetY, 20, 0, Math.PI * 2, false);\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n            \r\n            const node = {\r\n                centerX: offsetX,\r\n                centerY: offsetY,\r\n                id: index,\r\n                children: [],\r\n                isVisited:false,\r\n                parent:null,\r\n                costFromSource:Number.POSITIVE_INFINITY,\r\n            };\r\n            pushNode([...nodesOfGraph, node]);\r\n            writeText({text : `${node.id}`,x : node.centerX-10,y : node.centerY-10});\r\n        }\r\n        else {\r\n            if (!isDrawing) {\r\n                const { offsetX, offsetY } = nativeEvent;\r\n\r\n                const start = whichNode(offsetX, offsetY);\r\n                setStartNode(start);\r\n                // console.log(start);\r\n\r\n                if (start) {\r\n                    setIsDrawing(true);\r\n                    currentCoordinates = { x: offsetX, y: offsetY };\r\n                    contextRef.current.beginPath();\r\n                    contextRef.current.moveTo(offsetX, offsetY);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    const [currentEdgeWeight,setCurrentEdgeWeight] = useState(0);\r\n    const finishDrawing = () => {\r\n        if (!nodeDrawing) {\r\n\r\n            if (isDrawing && currentCoordinates) {\r\n                setIsDrawing(false);\r\n\r\n                const { x, y } = currentCoordinates;\r\n                const end = whichNode(x, y);\r\n                // console.log(end);\r\n\r\n                if (!end) {\r\n                    // dont draw the edge\r\n                    // dont push it into edges\r\n                    console.log(\"end node is null\");\r\n                    contextRef.current.closePath();\r\n                }\r\n                else if (end.id === startNode.id) {\r\n                    // dont draw the edge\r\n                    // dont push it into edges\r\n                    console.log(\"end node = start node\");\r\n                    contextRef.current.closePath();\r\n                }\r\n                else {\r\n                    contextRef.current.moveTo(startNode.centerX, startNode.centerY);\r\n                    contextRef.current.lineTo(end.centerX, end.centerY);\r\n                    contextRef.current.stroke();\r\n                    contextRef.current.closePath();\r\n                    \r\n                    let c =false;\r\n                    for(let i=0;i<startNode.children.length;i++){\r\n                        if(startNode.children[i].node === end){\r\n                            c = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(!c){\r\n                        const weight = currentEdgeWeight;\r\n                        const x = (startNode.centerX + end.centerX) / 2;\r\n                        const y = (startNode.centerY + end.centerY) / 2;\r\n                        startNode.children.push({ node: end, weight });\r\n                        end.children.push({ node: startNode, weight });\r\n                        writeText({ text: (weight?weight:''), x, y });\r\n                    }\r\n                }\r\n                currentCoordinates = null;\r\n                setStartNode(null);\r\n            }\r\n        }\r\n    };\r\n\r\n    const draw = ({ nativeEvent }) => {\r\n        const { offsetX, offsetY } = nativeEvent;\r\n        if (!nodeDrawing) {\r\n            if (isDrawing) {\r\n                currentCoordinates = { x: offsetX, y: offsetY };\r\n            }\r\n        }\r\n    };\r\n\r\n    const clearCanvas = () => {\r\n        const canvas = canvasRef.current;\r\n        const context = canvas.getContext(\"2d\");\r\n        context.fillStyle = \"white\";\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        pushNode([]);\r\n        setIndex(1);\r\n    }\r\n\r\n    return (\r\n        <CanvasContext.Provider\r\n            value={{\r\n                canvasRef,\r\n                contextRef,\r\n                prepareCanvas,\r\n                startDrawing,\r\n                finishDrawing,\r\n                clearCanvas,\r\n                draw,\r\n                toggleNodeDrawing,\r\n                nodeDrawing,\r\n                nodesOfGraph,\r\n                pushNode,\r\n                setIndex,\r\n                setCurrentEdgeWeight,\r\n            }}\r\n        >\r\n            {children}\r\n        </CanvasContext.Provider>\r\n    );\r\n};\r\n\r\n","import React, { useEffect, useContext, useLayoutEffect, useState } from \"react\";\r\nimport { CanvasContext } from \"./CanvasContext\";\r\n\r\nfunction CanvasBoard(props) {\r\n    const {\r\n        canvasRef,\r\n        prepareCanvas,\r\n        startDrawing,\r\n        finishDrawing,\r\n        draw,\r\n        toggleNodeDrawing,\r\n        nodeDrawing,\r\n        nodesOfGraph,\r\n        clearCanvas,\r\n        pushNode,\r\n        setIndex,\r\n        setCurrentEdgeWeight,\r\n    } = useContext(CanvasContext);\r\n\r\n    const emptyTheGraph = () => {\r\n        pushNode([]);\r\n        setIndex(1);\r\n    }\r\n\r\n    useEffect(() => {\r\n        prepareCanvas(props.height, props.width);\r\n        clearCanvas();\r\n        props.settingStartNode(null);\r\n        props.settingEndNode(null);\r\n    }, []);\r\n    const [startNode, setStartNode] = useState(0);\r\n    const [endNode, setEndNode] = useState(0);\r\n    useEffect(() => {\r\n        props.settingGraph(nodesOfGraph);\r\n        if (!startNode) props.settingStartNode((nodesOfGraph.length ? nodesOfGraph[0] : null));\r\n        if (!endNode) props.settingEndNode(nodesOfGraph.length ? nodesOfGraph[nodesOfGraph.length - 1] : null);\r\n        if (props.emptyGraphCall) {\r\n            emptyTheGraph();\r\n            props.toggleEmptyTheGraph();\r\n        }\r\n    }, [nodesOfGraph, props.emptyGraphCall]);\r\n\r\n\r\n\r\n    const startNodeUpdate = (event) => {\r\n        const startIndex = event.target.value;\r\n        setStartNode(startIndex);\r\n        if (startIndex != 0 && startIndex <= nodesOfGraph.length) props.settingStartNode(nodesOfGraph[startIndex - 1]);\r\n        else alert('Not a valid start node');\r\n    }\r\n    const endNodeUpdate = (event) => {\r\n        const endIndex = event.target.value;\r\n        setEndNode(endIndex);\r\n        if (endIndex != 0 && endIndex <= nodesOfGraph.length) props.settingEndNode(nodesOfGraph[endIndex - 1]);\r\n        else alert('Not a valid start node');\r\n    }\r\n\r\n///////////////////////////////////////// try doing without usingStates\r\n    const [weightNodeA,setWeightNodeA] = useState(0);\r\n    const [weightNodeB, setWeightNodeB] = useState(0);\r\n    const [weight,setWeight] = useState(0);\r\n    const weightNodeAUpdate = (event)=>{\r\n        const nodeIndex = event.target.value;\r\n        setWeightNodeA(nodeIndex);\r\n    }\r\n    const weightNodeBUpdate = (event) => {\r\n        const nodeIndex = event.target.value;\r\n        setWeightNodeB(nodeIndex);\r\n    }\r\n    const weightUpdate=(event)=>{\r\n        const weight=parseInt(event.target.value);\r\n        setWeight(weight);\r\n        setCurrentEdgeWeight(weight);\r\n    }\r\n    const writeText = (info, style = {}) => {\r\n        const canvas = canvasRef.current;\r\n        const ctx = canvas.getContext(\"2d\");\r\n        const { text, x, y } = info;\r\n        const { fontSize = 20, fontFamily = 'Arial', color = 'black', textAlign = 'left', textBaseline = 'top' } = style;\r\n\r\n        ctx.beginPath();\r\n        ctx.font = fontSize + 'px ' + fontFamily;\r\n        ctx.textAlign = textAlign;\r\n        ctx.textBaseline = textBaseline;\r\n        ctx.fillStyle = color;\r\n        ctx.fillText(text, x, y);\r\n        ctx.stroke();\r\n    }\r\n    const addWeightToEdge = () => {\r\n        const startId = weightNodeA;\r\n        const endId = weightNodeB;\r\n        const weightFinal = weight;\r\n        if(startId > 0 && endId>0 && startId<=nodesOfGraph.length && endId<=nodesOfGraph.length){\r\n            const startNode = nodesOfGraph[startId - 1];\r\n            const endNode = nodesOfGraph[endId - 1];\r\n            for (let i = 0; i < startNode.children.length; i++) {\r\n                let { node } = startNode.children[i];\r\n                if (node === endNode) {\r\n                    startNode.children[i].weight = weightFinal;\r\n                    for (let j = 0; j < endNode.children.length; j++) {\r\n                        let { node, weight } = endNode.children[j];\r\n                        if (node === startNode) {\r\n                            endNode.children[j].weight = weightFinal;\r\n                            const x = (startNode.centerX + endNode.centerX)/2;\r\n                            const y = (startNode.centerY + endNode.centerY)/2;\r\n                            writeText({text:weightFinal,x,y});\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        alert('No such edge exists');\r\n    }\r\n/////////////////////////////////////////////////////////////////////////\r\n    let edgeWeightInput = <div><a>Current edge weight</a>\r\n        <input id=\"edgeWeight\" onChange={weightUpdate} type=\"number\" value={weight} /></div>;\r\n    if(nodeDrawing){\r\n        edgeWeightInput = <div></div>\r\n    }\r\n    return (\r\n        <>\r\n            {/* <section id=\"canvas-container\"> */}\r\n            <div id=\"wrapper\" class=\"toggled\">\r\n                <div id=\"sidebar-wrapper\">\r\n                    <ul className=\"sidebar-nav\">\r\n                        <li className=\"sidebar-brand\"> <a href=\"#\"> Control Panel </a> </li>\r\n                        <li> \r\n                            <a href=\"#\" onClick={toggleNodeDrawing}>Add {nodeDrawing ? 'Edge' : 'Node'}</a> \r\n                            {edgeWeightInput}\r\n                        </li>\r\n                        <li>\r\n                            <a>Start Node</a>\r\n                            <input id=\"startValue\" type = \"number\" placeholder={nodesOfGraph.length ? '1' : '0'} onChange={startNodeUpdate} />\r\n                            <a>End Node</a>\r\n                            <input id=\"endValue\" type=\"number\" placeholder={nodesOfGraph.length} onChange={endNodeUpdate} />\r\n                        </li>\r\n                        {/* <li>\r\n                            <a>Add Weight</a>\r\n                            <a>Start Node</a>\r\n                            <input onChange={weightNodeAUpdate} type=\"number\" value ={weightNodeA}/>\r\n                            <a>End Node</a>\r\n                            <input onChange={weightNodeBUpdate} type=\"number\" value = {weightNodeB}/>\r\n                            <a>Weight</a>\r\n                            <input id=\"edgeWeight\" onChange={weightUpdate} type=\"number\" value = {weight}/>\r\n                            <button onClick = {addWeightToEdge}>Submit</button>\r\n                        </li> */}\r\n                    </ul>\r\n                </div>\r\n            </div>\r\n            <canvas id='canvas'\r\n                className=\"centercanvas\"\r\n                onMouseDown={props.isRunning?()=>{}:startDrawing}\r\n                onMouseUp={props.isRunning ? () => { } :finishDrawing}\r\n                onMouseMove={draw}\r\n                ref={canvasRef}\r\n            ></canvas>\r\n\r\n            <button ></button>\r\n            <br></br>\r\n            {/* </section> */}\r\n        </>\r\n    )\r\n}\r\n\r\nexport default CanvasBoard;","// BFS\r\nconst createEdge = (nodeA,nodeB)=>{\r\n    if(nodeA === null){\r\n        const xB = nodeB.centerX;\r\n        const yB = nodeB.centerY;\r\n        return {xB,yB,xB,yB};\r\n    }\r\n    const xA = nodeA.centerX;\r\n    const yA = nodeA.centerY;\r\n    const xB = nodeB.centerX;\r\n    const yB = nodeB.centerY;\r\n    const edge = {xA,yA,xB,yB};\r\n    return edge;\r\n}\r\n\r\nexport function bfs(graph, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    const visitedEdgesInOrder = [];\r\n    let bfsQueue = [startNode];\r\n    startNode.isVisited = true;\r\n\r\n    while (bfsQueue.length) {\r\n        const currentNode = bfsQueue.shift();\r\n        visitedNodesInOrder.push(currentNode);\r\n        visitedEdgesInOrder.push(createEdge(currentNode.parent, currentNode));\r\n        if (currentNode === finishNode) {\r\n            // console.log(visitedEdgesInOrder);\r\n            return { visitedNodesInOrder, visitedEdgesInOrder }\r\n        };\r\n        currentNode.children.forEach(childObject => {\r\n            const child = childObject.node;\r\n            if(!child.isVisited){\r\n                child.isVisited = true;\r\n                child.parent = currentNode;\r\n                // console.log(child);\r\n                bfsQueue.push(child);\r\n            }\r\n        });\r\n    }\r\n    return { visitedNodesInOrder, visitedEdgesInOrder };\r\n}","// DFS\r\nconst createEdge = (nodeA, nodeB) => {\r\n    const xA = nodeA.centerX;\r\n    const yA = nodeA.centerY;\r\n    const xB = nodeB.centerX;\r\n    const yB = nodeB.centerY;\r\n    const edge = { xA, yA, xB, yB };\r\n    return edge;\r\n}\r\n\r\nfunction getChildren(node) {\r\n    const childElements = [];\r\n\r\n    node.children.forEach((childObject) => {\r\n        const child = childObject.node;\r\n        if (!child.isVisited) {\r\n            childElements.push(child);\r\n        }\r\n    });\r\n\r\n    return childElements;\r\n}\r\n\r\nexport function dfs(graph, startNode, finishNode) {\r\n    const visitedNodesInOrder = [startNode];\r\n    const visitedEdgesInOrder = [];\r\n    startNode.isVisited = true;\r\n    let currentNode = startNode;\r\n    let dfsStack = [currentNode];\r\n    while (dfsStack.length) {\r\n        if (currentNode === finishNode) { \r\n            return { visitedNodesInOrder, visitedEdgesInOrder }; \r\n        }\r\n        const childElements = getChildren(currentNode);\r\n        if (childElements.length) {\r\n            childElements[0].parent = currentNode;\r\n            visitedEdgesInOrder.push(createEdge(currentNode, childElements[0]));\r\n            currentNode = childElements[0];\r\n            currentNode.isVisited = true;\r\n            visitedNodesInOrder.push(currentNode);\r\n            dfsStack.push(currentNode);\r\n        }\r\n        else {\r\n            dfsStack.pop();\r\n            currentNode = dfsStack[dfsStack.length - 1];\r\n        }\r\n    }\r\n    return { visitedNodesInOrder, visitedEdgesInOrder };\r\n}","// Dijkstra\r\n// still raw\r\n\r\nconst createEdge = (nodeA, nodeB) => {\r\n    const xA = nodeA.centerX;\r\n    const yA = nodeA.centerY;\r\n    const xB = nodeB.centerX;\r\n    const yB = nodeB.centerY;\r\n    const edge = { xA, yA, xB, yB };\r\n    return edge;\r\n}\r\n\r\nfunction getChildren(currentNode,visitedEdgesInOrder) {\r\n    const childNodes = [];\r\n    currentNode.children.forEach(childObject => {\r\n        const { node, weight } = childObject;\r\n        if (!node.isVisited) {\r\n            childNodes.push(node);\r\n            if (node.costFromSource > currentNode.costFromSource + weight) {\r\n                node.parent = currentNode;\r\n                visitedEdgesInOrder.push(createEdge(currentNode,node));\r\n            }\r\n            node.costFromSource = Math.min(node.costFromSource, currentNode.costFromSource + weight);\r\n        }\r\n        else if (node.isVisited) {\r\n            if (node.costFromSource > currentNode.costFromSource + weight) {\r\n                node.parent = currentNode;\r\n                visitedEdgesInOrder.push(createEdge(currentNode, node));\r\n            }\r\n            node.costFromSource = Math.min(node.costFromSource, currentNode.costFromSource + weight);\r\n        }\r\n    })\r\n    return childNodes;\r\n}\r\n\r\nfunction extractMinIndex(dijkstraPQ) {\r\n    let minNode = dijkstraPQ[0];\r\n    let minNodeIndex = 0;\r\n    for (let i = 1; i < dijkstraPQ.length; i++) {\r\n        let currentNode = dijkstraPQ[i];\r\n        if (minNode.costFromSource > currentNode.costFromSource) {\r\n            minNode = currentNode;\r\n            minNodeIndex = i;\r\n        }\r\n    }\r\n    return minNodeIndex;\r\n}\r\n\r\nexport function dijkstra(graph, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    const visitedEdgesInOrder = [];\r\n\r\n    let currentNode;\r\n    let dijkstraPQ = [startNode];\r\n    startNode.costFromSource = 0;\r\n    startNode.isVisited = true;\r\n    while (dijkstraPQ.length) {\r\n\r\n        const minIndex = extractMinIndex(dijkstraPQ);\r\n        currentNode = dijkstraPQ[minIndex];\r\n        if (currentNode === finishNode) {\r\n            visitedNodesInOrder.push(currentNode);\r\n            return { visitedNodesInOrder, visitedEdgesInOrder };\r\n        }\r\n\r\n        visitedNodesInOrder.push(currentNode);\r\n        const childNodes = getChildren(currentNode,visitedEdgesInOrder);\r\n        childNodes.forEach(node => {\r\n            dijkstraPQ.push(node);\r\n            node.isVisited = true;\r\n        });\r\n        dijkstraPQ.splice(minIndex, 1);\r\n    }\r\n    return {visitedNodesInOrder,visitedEdgesInOrder};\r\n}\r\n\r\n","const createEdge = (nodeA, nodeB) => {\r\n    const xA = nodeA.centerX;\r\n    const yA = nodeA.centerY;\r\n    const xB = nodeB.centerX;\r\n    const yB = nodeB.centerY;\r\n    const edge = { xA, yA, xB, yB };\r\n    return edge;\r\n}\r\n\r\nconst writeText = (info, style = {}) => {\r\n    const canvas = document.getElementById('canvas');\r\n    const ctx = canvas.getContext(\"2d\");\r\n    const { text, x, y } = info;\r\n    const { fontSize = 20, fontFamily = 'Arial', color = 'black', textAlign = 'left', textBaseline = 'top' } = style;\r\n\r\n    ctx.beginPath();\r\n    ctx.font = fontSize + 'px ' + fontFamily;\r\n    ctx.textAlign = textAlign;\r\n    ctx.textBaseline = textBaseline;\r\n    ctx.fillStyle = color;\r\n    ctx.fillText(text, x, y);\r\n    ctx.stroke();\r\n}\r\n\r\nexport function visitAllEdges(graph) {\r\n    let canvas = document.getElementById('canvas');\r\n    const ctx = canvas.getContext(\"2d\");\r\n    ctx.fillStyle = \"white\";\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n    graph.forEach((node) => {\r\n        node.isVisited = false;\r\n        node.parent = null;\r\n        node.costFromSource = Number.POSITIVE_INFINITY;\r\n    });\r\n\r\n    graph.forEach((node) => {\r\n        writeText({ text: `${node.id}`, x: node.centerX - 35, y: node.centerY - 35 });\r\n        if (!node.isVisited) {\r\n\r\n            ctx.strokeStyle = \"#000000\";\r\n            let { centerX, centerY } = node;\r\n            ctx.beginPath();\r\n            ctx.moveTo(centerX, centerY);\r\n            ctx.arc(centerX, centerY, 20, 0, Math.PI * 2, true);\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n\r\n            let bfsQueue = [node];\r\n            while (bfsQueue.length) {\r\n                const currentNode = bfsQueue.shift();\r\n                currentNode.isVisited = true;\r\n                currentNode.children.forEach(childObject => {\r\n                    const child = childObject.node;\r\n                    if (!child.isVisited) {\r\n                        const edge = createEdge(currentNode, child);\r\n                        const { xA, yA, xB, yB } = edge;\r\n                        const x = (xA + xB) / 2;\r\n                        const y = (yA + yB) / 2;\r\n                        const weight = (childObject.weight ? childObject.weight:'');\r\n                        writeText({text:weight,x,y});\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(xA, yA);\r\n                        ctx.lineTo(xB, yB);\r\n                        ctx.stroke();\r\n                        ctx.closePath();\r\n                        ctx.beginPath();\r\n                        ctx.arc(xB, yB, 20, 0, Math.PI * 2, false);\r\n                        ctx.stroke();\r\n                        ctx.closePath();\r\n                        bfsQueue.push(child);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n\r\n    graph.forEach((node) => {\r\n        node.isVisited = false;\r\n        node.parent = null;\r\n        node.costFromSource = Number.POSITIVE_INFINITY;\r\n    });\r\n}","import DisjointSet from '../../Data Structures/disjointSet';\r\n\r\nconst getEdgeWeight = (nodeA, nodeB) => {\r\n    for (let i = 0; i < nodeA.children.length; i++) {\r\n        const { node, weight } = nodeA.children[i];\r\n        if (node === nodeB) {\r\n            return weight;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nconst createEdge = (nodeA, nodeB) => {\r\n    const edgeWeight = getEdgeWeight(nodeA, nodeB);\r\n    const edge = { nodeA, nodeB, edgeWeight };\r\n    return edge;\r\n}\r\n\r\nfunction compare(edgeA, edgeB) {\r\n    return edgeA.edgeWeight - edgeB.edgeWeight;\r\n}\r\n\r\nexport function kruskalsMST(graph) {\r\n    let disjointSet = new DisjointSet((node) => {\r\n        return node.id;\r\n    });\r\n    graph.forEach((node) => {\r\n        node.isVisited = false;\r\n        node.parent = null;\r\n        node.costFromSource = Number.POSITIVE_INFINITY;\r\n        disjointSet.makeSet(node);\r\n    });\r\n    const graphEdges = [];\r\n    graph.forEach((node) => {\r\n        if (!node.isVisited) {\r\n            let bfsQueue = [node];\r\n            while (bfsQueue.length) {\r\n                const currentNode = bfsQueue.shift();\r\n                currentNode.isVisited = true;\r\n                currentNode.children.forEach(childObject => {\r\n                    const child = childObject.node;\r\n                    if (!child.isVisited) {\r\n                        const edge = createEdge(currentNode, child);\r\n                        graphEdges.push(edge);\r\n                        bfsQueue.push(child);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n    graphEdges.sort(compare);\r\n\r\n    const kruskalSelectedEdges = [];\r\n    graphEdges.forEach((edge) => {\r\n        const {nodeA,nodeB} = edge;\r\n        if(!disjointSet.inSameSet(nodeA,nodeB)){\r\n            kruskalSelectedEdges.push(edge);\r\n            disjointSet.union(nodeA,nodeB);\r\n        }\r\n    });\r\n\r\n    // graph.forEach((node) => {\r\n    //     node.isVisited = false;\r\n    //     node.parent = null;\r\n    //     node.costFromSource = Number.POSITIVE_INFINITY;\r\n    // });\r\n\r\n    return kruskalSelectedEdges;\r\n\r\n}","import DisjointSet from '../../Data Structures/disjointSet';\r\n\r\nconst getEdgeWeight = (nodeA, nodeB) => {\r\n    for (let i = 0; i < nodeA.children.length; i++) {\r\n        const { node, weight } = nodeA.children[i];\r\n        if (node === nodeB) {\r\n            return weight;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nconst createEdge = (nodeA, nodeB) => {\r\n    const edgeWeight = getEdgeWeight(nodeA, nodeB);\r\n    const edge = { nodeA, nodeB, edgeWeight };\r\n    return edge;\r\n}\r\n\r\nfunction compare(edgeA, edgeB) {\r\n    return edgeA.edgeWeight - edgeB.edgeWeight;\r\n}\r\n\r\nexport function primsMST(graph) {\r\n    let disjointSet = new DisjointSet((node) => {\r\n        return node.id;\r\n    });\r\n    graph.forEach((node) => {\r\n        node.isVisited = false;\r\n        node.parent = null;\r\n        node.costFromSource = Number.POSITIVE_INFINITY;\r\n        disjointSet.makeSet(node);\r\n    });\r\n    const primSelectedEdges = [];\r\n\r\n    let currentNode = graph[0];\r\n    const graphEdgesQueue = [];\r\n    for(let i=0;i<currentNode.children.length;i++){\r\n        const {node,weight} = currentNode.children[i];\r\n        graphEdgesQueue.push(createEdge(currentNode,node));\r\n    }\r\n    graphEdgesQueue.sort(compare);\r\n    \r\n    while(graphEdgesQueue.length){\r\n        const { nodeA, nodeB} = graphEdgesQueue[0];\r\n        if(!disjointSet.inSameSet(nodeA,nodeB)){\r\n            disjointSet.union(nodeA,nodeB);\r\n            currentNode = graphEdgesQueue[0].nodeB;\r\n            primSelectedEdges.push(graphEdgesQueue.shift());\r\n            for (let i = 0; i < currentNode.children.length; i++) {\r\n                const { node } = currentNode.children[i];\r\n                graphEdgesQueue.push(createEdge(currentNode, node));\r\n            }\r\n            graphEdgesQueue.sort(compare);\r\n        }\r\n        else graphEdgesQueue.shift();\r\n    }\r\n\r\n    return primSelectedEdges;\r\n}","import React, { useContext } from 'react';\r\nimport './Canvas.css';\r\nimport Navbar from '../Navbar';\r\nimport CanvasBoard from './CanvasBoard';\r\nimport { CanvasProvider } from './CanvasContext';\r\nimport { bfs } from './Algorithms/bfs';\r\nimport { dfs } from './Algorithms/dfs';\r\nimport { dijkstra } from './Algorithms/dijkstra';\r\nimport { visitAllEdges } from \"./Algorithms/visitAllEdges\";\r\nimport { kruskalsMST } from './Algorithms/kruskals';\r\nimport { primsMST } from './Algorithms/prims';\r\nclass Canvas extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            navbarHeight: 0,\r\n            height: 0,\r\n            width: 0,\r\n            graphOfNodes: [],\r\n            isRunning: false,\r\n            emptyGraphCall: false,\r\n            startNode: null,\r\n            endNode: null,\r\n        }\r\n    }\r\n    toggleEmptyTheGraph = () => {\r\n        const emptyGraphCall = !this.state.emptyGraphCall;\r\n        this.setState({ emptyGraphCall });\r\n    }\r\n    clearCanvas = () => {\r\n        this.setState({ emptyGraphCall: true });\r\n        const canvas = document.getElementById('canvas');\r\n        const context = canvas.getContext(\"2d\");\r\n        context.fillStyle = \"white\";\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n    }\r\n\r\n    settingStartNode = (startNode) => {\r\n        this.setState({ startNode });\r\n    }\r\n    settingEndNode = (endNode) => {\r\n        this.setState({ endNode });\r\n    }\r\n    settingGraph = (graphOfNodes) => {\r\n        this.setState({ graphOfNodes });\r\n    }\r\n\r\n    redrawGraph = () => {\r\n        const graphOfNodes = this.state.graphOfNodes;\r\n        visitAllEdges(graphOfNodes);\r\n    }\r\n\r\n    visualize(algo) {\r\n        if (!this.state.isRunning) {\r\n            const graphOfNodes = this.state.graphOfNodes;\r\n            if (!graphOfNodes.length) {\r\n                alert('Canvas is empty');\r\n                return;\r\n            }\r\n            this.setState({ isRunning: true });\r\n            this.redrawGraph();\r\n            let startNode = this.state.startNode, finishNode = this.state.endNode;\r\n\r\n            let visitedNodesInOrder1;\r\n            let visitedEdgesInOrder1;\r\n            switch (algo) {\r\n                case 'Dijkstra':\r\n                    {\r\n                        const { visitedNodesInOrder, visitedEdgesInOrder } = dijkstra(graphOfNodes, startNode, finishNode);\r\n                        visitedNodesInOrder1 = visitedNodesInOrder;\r\n                        visitedEdgesInOrder1 = visitedEdgesInOrder;\r\n                        break;\r\n                    }\r\n                case 'BFS':\r\n                    {\r\n                        const { visitedNodesInOrder, visitedEdgesInOrder } = bfs(graphOfNodes, startNode, finishNode);\r\n                        visitedNodesInOrder1 = visitedNodesInOrder;\r\n                        visitedEdgesInOrder1 = visitedEdgesInOrder;\r\n                        break;\r\n                    }\r\n                case 'DFS':\r\n                    {\r\n                        const { visitedNodesInOrder, visitedEdgesInOrder } = dfs(graphOfNodes, startNode, finishNode);\r\n                        visitedNodesInOrder1 = visitedNodesInOrder;\r\n                        visitedEdgesInOrder1 = visitedEdgesInOrder;\r\n                        break;\r\n                    }\r\n                default:\r\n                    // should never get here\r\n                    break;\r\n            }\r\n            visitedNodesInOrder1.forEach(node => {\r\n                console.log(node.id, node.costFromSource);\r\n            });\r\n            this.animate(visitedNodesInOrder1, visitedEdgesInOrder1, algo, finishNode);\r\n        }\r\n    }\r\n\r\n\r\n    animate = (visitedNodesInOrder, visitedEdgesInOrder, algo, finishNode) => {\r\n        let canvas = document.getElementById('canvas');\r\n        let ctx = canvas.getContext('2d');\r\n        ctx.fillStyle = \"green\";\r\n        ctx.strokeStyle = '#ff0000';\r\n        ctx.lineWidth = 1;\r\n\r\n        let { centerX, centerY } = visitedNodesInOrder[0];\r\n        ctx.beginPath();\r\n        ctx.moveTo(centerX, centerY);\r\n        ctx.arc(centerX, centerY, 20, 0, Math.PI * 2, false);\r\n        ctx.fill();\r\n        ctx.closePath();\r\n\r\n        for (let i = 0; i < visitedEdgesInOrder.length; i++) {\r\n            const { xA, yA, xB, yB } = visitedEdgesInOrder[i];\r\n\r\n            setTimeout(() => {\r\n                setTimeout(() => {\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(xA, yA);\r\n                    ctx.lineTo(xB, yB);\r\n                    ctx.stroke();\r\n                    ctx.closePath();\r\n                }, 500);\r\n\r\n                setTimeout(() => {\r\n                    ctx.beginPath();\r\n                    ctx.arc(xB, yB, 20, 0, Math.PI * 2, false);\r\n                    ctx.fill();\r\n                    ctx.closePath();\r\n                }, 1000);\r\n            }, i * 1000);\r\n\r\n        }\r\n        if (visitedNodesInOrder[visitedNodesInOrder.length - 1] === finishNode) {\r\n            setTimeout(() => {\r\n                this.animateShortestPath(finishNode, visitedNodesInOrder);\r\n            }, 1000 * (visitedEdgesInOrder.length + 1) + 100);\r\n        }\r\n        else {\r\n            setTimeout(() => {\r\n                ctx.fillStyle = \"#ffffff\";\r\n                ctx.strokeStyle = '#000000';\r\n                this.setState({ isRunning: false });\r\n                alert('node not reachable');\r\n            }, 1000 * visitedNodesInOrder.length + 100);\r\n        }\r\n\r\n    }\r\n    animateShortestPath = (endNode, visitedNodesInOrder) => {\r\n        let shortestPathNodes = [];\r\n        let currentNode = endNode;\r\n        while (currentNode) {\r\n            shortestPathNodes.push(currentNode);\r\n            currentNode = currentNode.parent;\r\n        }\r\n        let canvas = document.getElementById('canvas');\r\n        let ctx = canvas.getContext('2d');\r\n        ctx.fillStyle = \"yellow\";\r\n\r\n        for (let i = shortestPathNodes.length - 1; i >= 0; i--) {\r\n            setTimeout(() => {\r\n                const node = shortestPathNodes[i];\r\n                const { centerX, centerY } = node;\r\n                ctx.beginPath();\r\n                ctx.arc(centerX, centerY, 20, 0, Math.PI * 2, false);\r\n                ctx.fill();\r\n                ctx.closePath();\r\n            }, (shortestPathNodes.length - 1 - i) * 500);\r\n        }\r\n        setTimeout(() => {\r\n            ctx.fillStyle = \"#ffffff\";\r\n            ctx.strokeStyle = '#000000';\r\n            this.setState({ isRunning: false });\r\n            shortestPathNodes = [];\r\n        }, 500 * (shortestPathNodes.length) + 1000);\r\n    }\r\n\r\n    visualizeMST = (algo) => {\r\n        if (!this.state.isRunning) {\r\n            const graphOfNodes = this.state.graphOfNodes;\r\n            if (!graphOfNodes.length) {\r\n                alert('Canvas is empty');\r\n                return;\r\n            }\r\n            this.setState({ isRunning: true });\r\n            this.redrawGraph();\r\n            let MSTedges = [];\r\n            switch (algo) {\r\n                case 'Kruskal':\r\n                {\r\n                    MSTedges = kruskalsMST(graphOfNodes);\r\n                    console.log(MSTedges);\r\n                    break;\r\n                }\r\n                case 'Prims':\r\n                {\r\n                    MSTedges = primsMST(graphOfNodes);\r\n                    break;\r\n                }\r\n                default:\r\n                    // do nothing\r\n                    console.log(\"here\");\r\n                    break;\r\n            }\r\n            if(MSTedges.length) this.animateMST(MSTedges);\r\n            else{\r\n                this.setState({ isRunning: false });\r\n                console.log(\"ERROR\");\r\n            }\r\n        }\r\n    }\r\n    animateMST = (MSTedges) => {\r\n        let canvas = document.getElementById('canvas');\r\n        let ctx = canvas.getContext('2d');\r\n        ctx.strokeStyle = '#ff0000';\r\n        ctx.lineWidth = 5;\r\n\r\n        for(let i=0;i<MSTedges.length;i++){\r\n            setTimeout(()=>{\r\n                const { nodeA, nodeB } = MSTedges[i];\r\n                const xA = nodeA.centerX;\r\n                const yA = nodeA.centerY;\r\n                const xB = nodeB.centerX;\r\n                const yB = nodeB.centerY;\r\n                ctx.beginPath();\r\n                ctx.moveTo(xA, yA);\r\n                ctx.lineTo(xB, yB);\r\n                ctx.stroke();\r\n                ctx.closePath();\r\n            },i*500);\r\n        }\r\n        setTimeout(()=>{\r\n            ctx.strokeStyle = '#000000';\r\n            ctx.lineWidth = 1;\r\n            this.setState({isRunning:false});\r\n        },MSTedges.length*500+100);\r\n    }\r\n    toggleCanvas = () => {\r\n        const canvasOrGrid = !this.state.canvasOrGrid;\r\n        this.setState({ canvasOrGrid });\r\n        this.props.toggleCanvas();\r\n    }\r\n    render() {\r\n        const height = document.documentElement.clientHeight - 50;\r\n        const width = document.documentElement.clientWidth - 30;\r\n        return (\r\n            <div>\r\n                <CanvasProvider>\r\n                    <Navbar\r\n                        isCanvas={this.props.isCanvas}\r\n                        toggleCanvas={() => this.toggleCanvas()}\r\n                        bfs={() => this.visualize('BFS')}\r\n                        dfs={() => this.visualize('DFS')}\r\n                        dijkstra={() => this.visualize('Dijkstra')}\r\n                        clearGrid={() => this.redrawGraph()}\r\n                        resetGrid={() => this.clearCanvas()}\r\n                        kruskalMST={() => this.visualizeMST('Kruskal')}\r\n                        primMST={() => this.visualizeMST('Prims')}\r\n                    ></Navbar>\r\n                    <CanvasBoard\r\n                        height={height}\r\n                        width={width}\r\n                        settingGraph={this.settingGraph}\r\n                        settingStartNode={this.settingStartNode}\r\n                        settingEndNode={this.settingEndNode}\r\n                        emptyGraphCall={this.state.emptyGraphCall}\r\n                        toggleEmptyTheGraph={this.toggleEmptyTheGraph}\r\n                        isRunning={this.state.isRunning}\r\n                    ></CanvasBoard>\r\n                </CanvasProvider>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Canvas;","import React from 'react';\nimport './App.css';\n// import Navbar from './Navbar';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer'\nimport Canvas from './Canvas/Canvas'\n\nclass App extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {\n      canvas: false,\n    }\n  }\n\n  toggleCanvas = ()=>{\n    const canvas = !this.state.canvas;\n    this.setState({canvas});\n  }\n\n  render(){\n\n    if(!this.state.canvas){\n      return (\n        <div className=\"App\">\n          <PathfindingVisualizer\n              toggleCanvas={()=>this.toggleCanvas()}\n              isCanvas = {this.state.canvas}\n          ></PathfindingVisualizer>\n        </div>\n      )\n    }\n    else {\n      return (\n        <div className=\"App\">\n          <Canvas\n            toggleCanvas={() => this.toggleCanvas()}\n            isCanvas={this.state.canvas}\n          ></Canvas>\n        </div>\n      )\n    } \n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}