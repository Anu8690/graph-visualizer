{"version":3,"sources":["PathfindingVisualizer/Node/Node.js","PathfindingVisualizer/Algorithms/dfs.js","PathfindingVisualizer/Algorithms/dijkstra.js","PathfindingVisualizer/Mazes/maze.js","PathfindingVisualizer/Mazes/weightMaze.js","Navbar.js","PathfindingVisualizer/Mazes/hSkewMaze.js","PathfindingVisualizer/Mazes/vSkewMaze.js","Data Structures/disjointSetItem.js","Data Structures/disjointSet.js","PathfindingVisualizer/Mazes/kruskalsMaze1.js","PathfindingVisualizer/Mazes/primsMaze.js","PathfindingVisualizer/PathfindingVisualizer.js","PathfindingVisualizer/Mazes/wallMaze.js","PathfindingVisualizer/Algorithms/bfs.js","Canvas/CanvasContext.js","Canvas/CanvasBoard.js","Canvas/Algorithms/bfs.js","Canvas/Algorithms/dfs.js","Canvas/Algorithms/dijkstra.js","Canvas/Algorithms/visitAllEdges.js","Canvas/Algorithms/kruskals.js","Canvas/Algorithms/prims.js","Canvas/Canvas.js","App.js","index.js"],"names":["Node","props","this","row","col","weight","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","extraClassName","id","className","React","Component","getChildren","node","grid","childElements","forEach","direction","childRow","childCol","length","child","isVisited","push","childNodes","childNode","costFromSource","parent","Math","min","extractMinIndex","dijkstraPQ","minNode","minNodeIndex","i","currentNode","createNode","finishNode","startNode","srow","scol","frow","fcol","isNode","Number","POSITIVE_INFINITY","removeWall","nodeA","nodeB","rowA","colA","rowB","colB","r","floor","c","maze","rowNum","colNum","newNode","initialGrid","dfsStack","random","pop","weightMaze","Navbar","onVisualizeClick","state","visualize","bfs","dfs","dijkstra","alert","toggleCanvas","bfsClick","setState","dfsClick","dijkstraClick","onWeightWallToggleClick","weightOrWall","weightWallToggle","componentDidMount","navbarHeight","document","getElementById","clientHeight","isCanvas","clearGrid","resetGrid","mazify","hmazify","vmazify","kruskalMazify","primMazify","weightMazify","wallMazify","clearWallsandWeights","kruskalMST","primMST","mazeOptions","data-toggle","href","onClick","weightAndWallOption","addWeightOption","type","vChildElements","hChildElements","horizontalSkewMaze","random1","verticalSkewMaze","DisjointSetItem","value","keyCallback","children","isRoot","getRoot","rank","getRank","Object","values","parentItem","forceSettingParentChild","addChild","childItem","getKey","setParent","DisjointSet","items","itemValue","disjointSetItem","templateDisjointItem","requiredDisjointItem","valueA","valueB","rootKeyA","find","rootKeyB","Error","rootA","rootB","disjointSet","index","hWallSet","vWallSet","kruskalMaze","makeSet","random2","neighborNodeRight","neighborNodeLeft","inSameSet","union","splice","unionJoint","primMaze","edgeQueue","PathfindingVisualizer","height","toggleIsRunning","isRunning","toggleWeightWallToggle","getInitialGrid","rowCount","ROW_COUNT","colCount","COLUMN_COUNT","currentRow","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","onCellDown","mouseIsPressed","startNodePressed","finishNodePressed","onCellEnter","onCellLeave","onCellRelease","componentWillMount","documentElement","clientWidth","console","log","hSkewMazify","vSkewMazify","wallMaze","algo","visitedNodesInOrder","minIndex","bfsQueue","childDirections","shift","x","y","nodesInShortestPathOrder","getNodesInShortestPathOrder","animate","setTimeout","animateShortestPath","nodeClassName","unshift","map","rowID","nodeID","CanvasContext","createContext","CanvasProvider","useState","isDrawing","setIsDrawing","nodeDrawing","setNodeDrawing","setIndex","canvasRef","useRef","contextRef","nodesOfGraph","pushNode","squareDistance","pow","centerX","centerY","setStartNode","currentCoordinates","whichNode","writeText","info","style","canvas","current","ctx","getContext","text","fontSize","fontFamily","color","textAlign","textBaseline","beginPath","font","fillStyle","fillText","stroke","currentEdgeWeight","setCurrentEdgeWeight","Provider","prepareCanvas","width","context","lineCap","strokeStyle","lineWidth","startDrawing","nativeEvent","offsetX","offsetY","prevIndex","arc","PI","closePath","start","moveTo","finishDrawing","end","lineTo","clearCanvas","fillRect","draw","toggleNodeDrawing","CanvasBoard","useContext","useEffect","settingStartNode","settingEndNode","endNode","setEndNode","settingGraph","emptyGraphCall","toggleEmptyTheGraph","weightNodeA","setWeightNodeA","weightNodeB","setWeightNodeB","setWeight","weightUpdate","event","parseInt","target","edgeWeightInput","onChange","class","placeholder","startIndex","endIndex","nodeIndex","startId","endId","weightFinal","j","onMouseMove","ref","graph","visitedEdgesInOrder","xB","yB","xA","yA","createEdge","childObject","compare","edgeA","edgeB","edgeWeight","getEdgeWeight","nheight","Canvas","graphOfNodes","redrawGraph","edge","visitAllEdges","fill","shortestPathNodes","visualizeMST","MSTedges","graphEdges","sort","kruskalSelectedEdges","kruskalsMST","primSelectedEdges","graphEdgesQueue","primsMST","animateMST","canvasOrGrid","visitedNodesInOrder1","visitedEdgesInOrder1","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.5381ba02.chunk.js","sourcesContent":["import React from 'react';\r\nimport './Node.css'\r\nclass Node extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n    render() {\r\n        const {\r\n            row,\r\n            col,\r\n            weight,\r\n            isFinish,\r\n            isStart,\r\n            isWall,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            onMouseLeave,\r\n        } = this.props;\r\n        const extraClassName = isFinish ? \"node-finish\" : isStart ? \"node-start\" : isWall ? \"node-wall\" : \"\";\r\n        return (\r\n            <td\r\n                id={`node-${row}-${col}`}\r\n                className={`node ${extraClassName}`}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp()}\r\n                onMouseLeave={() => onMouseLeave(row,col)}\r\n            ><small>{weight === 1 ? \"\" : weight}</small></td> // It is used to create the grid.\r\n        );\r\n    }\r\n}\r\nexport default Node;","// DFS\r\n\r\nfunction getChildren(node, grid) {\r\n    const { row, col } = node;\r\n    const childElements = [];\r\n    const childDirections = [[1, 0], [0, 1], [-1, 0], [0, -1]];\r\n\r\n    childDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited && !child.isWall) {\r\n                // child.isVisited = true;\r\n                childElements.push(child);\r\n            }\r\n        }\r\n    })\r\n\r\n    return childElements;\r\n}\r\n\r\n\r\nexport function dfs(grid,startNode,finishNode){\r\n    const visitedNodesInOrder = [startNode];\r\n    startNode.isVisited= true;\r\n    let currentNode = startNode;\r\n    let dfsStack = [currentNode];\r\n    while (dfsStack.length) {\r\n        if(currentNode.isFinish) return visitedNodesInOrder;\r\n        const childElements = getChildren(currentNode, grid);\r\n        if (childElements.length) {\r\n            childElements[0].parent = currentNode;\r\n            currentNode = childElements[0];\r\n            currentNode.isVisited = true;\r\n            visitedNodesInOrder.push(currentNode);\r\n            dfsStack.push(currentNode);\r\n        }\r\n        else { \r\n            dfsStack.pop();\r\n            currentNode = dfsStack[dfsStack.length-1];\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n","// Dijkstra\r\n\r\nfunction getChildren (grid,node){\r\n    const childDirections = [[1,0],[0,1],[-1,0],[0,-1]];\r\n    const childNodes = [];\r\n    const {row,col} = node;\r\n    childDirections.forEach(direction=>{\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n\r\n        if(childRow >=0&& childCol>=0 && childCol<grid[0].length && childRow<grid.length)\r\n        {\r\n            const childNode = grid[childRow][childCol];\r\n            if(!childNode.isVisited && !childNode.isWall)\r\n            {\r\n                childNodes.push(childNode);\r\n                if(childNode.costFromSource > node.costFromSource + childNode.weight)\r\n                {\r\n                    childNode.parent = node;\r\n                }\r\n                childNode.costFromSource = Math.min(childNode.costFromSource, node.costFromSource + childNode.weight);\r\n            }\r\n            else if(childNode.isVisited)\r\n            {\r\n                if (childNode.costFromSource > node.costFromSource + childNode.weight) {\r\n                    childNode.parent = node;\r\n                }\r\n                childNode.costFromSource = Math.min(childNode.costFromSource, node.costFromSource + childNode.weight);\r\n                // console.log(\"parent = \",row,col,childNode.costFromSource)\r\n            }\r\n        }\r\n    })\r\n    return childNodes;\r\n}\r\n\r\nfunction extractMinIndex (dijkstraPQ){\r\n    let minNode = dijkstraPQ[0];\r\n    let minNodeIndex=0;\r\n    for(let i=1;i<dijkstraPQ.length;i++)\r\n    {\r\n        let currentNode = dijkstraPQ[i];\r\n        if(minNode.costFromSource > currentNode.costFromSource)\r\n        {\r\n            minNode = currentNode;\r\n            minNodeIndex = i;\r\n        }\r\n    }\r\n    return minNodeIndex;\r\n}\r\n\r\nexport function dijkstra(grid,startNode,finishNode){\r\n    const visitedNodesInOrder = [];\r\n\r\n    let currentNode;\r\n    let dijkstraPQ = [startNode];\r\n    startNode.isVisited=true;\r\n    while(dijkstraPQ.length)\r\n    {\r\n\r\n        const minIndex = extractMinIndex(dijkstraPQ);\r\n        currentNode = dijkstraPQ[minIndex];\r\n        if(currentNode.isFinish) return visitedNodesInOrder;\r\n\r\n        visitedNodesInOrder.push(currentNode);\r\n        const childNodes = getChildren(grid,currentNode);\r\n        childNodes.forEach(node => {\r\n            dijkstraPQ.push(node);\r\n            node.isVisited=true;\r\n        });\r\n        dijkstraPQ.splice(minIndex,1);\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\n","function createNode (row,col,finishNode,startNode){\r\n    const srow = startNode.row;\r\n    const scol = startNode.col;\r\n    const frow = finishNode.row;\r\n    const fcol = finishNode.col;\r\n    return {\r\n        row : row,\r\n        col : col,\r\n        isVisited : false,\r\n        isWall : false,\r\n        parent: null,\r\n        isNode: true,\r\n        isStart:\r\n            row === srow && col === scol,\r\n        isFinish:\r\n            row === frow && col === fcol,\r\n        weight :1,\r\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\r\n    };\r\n}\r\n\r\n// assumed rowNum ans colNum are odd\r\n\r\nfunction initialGrid (rowNum,colNum,startNode,finishNode){\r\n    const grid = [];\r\n    for(let r = 0;r<rowNum;r++)\r\n    {\r\n        const row = [];\r\n        for(let c = 0; c<colNum;c++)\r\n        {\r\n            const newNode = createNode(r,c,finishNode,startNode);\r\n            if((r%2==0 || c%2==0 )) newNode.isWall = true;\r\n            if(newNode.isFinish || newNode.isStart) newNode.isWall = false;\r\n            row.push(newNode);\r\n        }\r\n        grid.push(row);\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction getChildren (node,grid){\r\n    const {row,col} = node;\r\n    const childElements = [];\r\n    const childDirections = [[2,0],[0,2],[-2,0],[0,-2]];\r\n    \r\n    childDirections.forEach(direction=>{\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if(childRow>=0 && childCol >=0 && childRow < grid.length && childCol < grid[0].length)\r\n        {\r\n            const child = grid[childRow][childCol];\r\n            if(!child.isVisited)\r\n            {\r\n                // child.isVisited = true;\r\n                childElements.push(child);\r\n            }\r\n        }\r\n    })\r\n\r\n    return childElements;\r\n}\r\n\r\nfunction removeWall(nodeA,nodeB,grid){\r\n    \r\n    const rowA = nodeA.row;\r\n    const colA = nodeA.col;\r\n    const rowB = nodeB.row;\r\n    const colB = nodeB.col;\r\n\r\n    const r = Math.floor((rowA+rowB)/2);\r\n    const c = Math.floor((colA+colB)/2);\r\n\r\n    grid[r][c].isWall = false;\r\n    return;\r\n}\r\n\r\nexport function maze(rowNum,colNum,startNode,finishNode){\r\n    const grid = initialGrid(rowNum,colNum,startNode,finishNode);\r\n    // console.log(grid);\r\n    \r\n    let currentNode = grid[1][1];\r\n    let dfsStack = [currentNode];\r\n\r\n    while(dfsStack.length)\r\n    {\r\n        const childElements = getChildren(currentNode,grid);\r\n        if(childElements.length)\r\n        {\r\n            const random = Math.floor(Math.random() * childElements.length);\r\n            // console.log(currentNode, childElements[random], removeWall(currentNode, childElements[random]));\r\n            removeWall(currentNode,childElements[random],grid);\r\n            currentNode = childElements[random];\r\n            currentNode.isVisited = true;\r\n            dfsStack.push(currentNode);\r\n        }\r\n        else\r\n        {\r\n            currentNode = dfsStack.pop();\r\n        }\r\n        // console.log(currentNode);\r\n    }\r\n    grid.forEach(row=>{\r\n        row.forEach(node => {\r\n            node.isVisited = false;\r\n        });\r\n    });\r\n    // console.log(grid);\r\n    return grid;\r\n}\r\n\r\n","function distribution(){\r\n    const random1 = Math.random();\r\n    if(random1 <0.5)\r\n    {\r\n        const random2 = Math.floor(Math.random()*10 + 1);\r\n        return random2;\r\n    }\r\n    return 1;\r\n}\r\nexport function weightMaze(grid){\r\n    grid.forEach(row=>{\r\n        row.forEach(node =>{\r\n            if(!node.isWall){\r\n                node.weight = distribution();\r\n            }\r\n        });\r\n    });\r\n    return grid;\r\n}","import React from 'react';\r\nclass Navbar extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            visualize: '',\r\n            weightOrWall: false,\r\n            isCanvas: this.props.isCanvas,\r\n        }\r\n    }\r\n    onVisualizeClick = () => {\r\n        const visualize = this.state.visualize;\r\n        switch (visualize) {\r\n            case 'BFS':\r\n                this.props.bfs();\r\n                break;\r\n            case 'DFS':\r\n                this.props.dfs();\r\n                break;\r\n            case 'Dijkstra':\r\n                this.props.dijkstra();\r\n                break;\r\n            default:\r\n                alert('Choose an algorithm for visualization!!');\r\n        }\r\n    }\r\n    toggleCanvas = () => {\r\n        this.props.toggleCanvas();\r\n    }\r\n    bfsClick = () => {\r\n        this.setState({ visualize: 'BFS' });\r\n    }\r\n    dfsClick = () => {\r\n        this.setState({ visualize: 'DFS' });\r\n    }\r\n    dijkstraClick = () => {\r\n        this.setState({ visualize: 'Dijkstra' });\r\n    }\r\n    onWeightWallToggleClick = () => {\r\n        const weightOrWall = !this.state.weightOrWall;\r\n        this.setState({ weightOrWall });\r\n        this.props.weightWallToggle();\r\n    }\r\n    componentDidMount = () => {\r\n        this.props.navbarHeight(document.getElementById(\"navbarDiv\").clientHeight);\r\n    }\r\n    render() {\r\n        const {\r\n            clearGrid,\r\n            resetGrid,\r\n            mazify,\r\n            hmazify,\r\n            vmazify,\r\n            kruskalMazify,\r\n            primMazify,\r\n            weightMazify,\r\n            wallMazify,\r\n            clearWallsandWeights,\r\n            kruskalMST,\r\n            primMST,\r\n        } = this.props;\r\n\r\n        let mazeOptions = <li className=\"dropdown\">\r\n            <a className=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Mazes &amp; Patterns\r\n             <span className=\"caret\"></span></a>\r\n            <ul className=\"dropdown-menu\">\r\n                <li id='startButtonCreateMazeTwo'><a href=\"#\" onClick={mazify}>Recursive Division</a></li>\r\n                <li id='startButtonCreateMazeThree'><a href=\"#\" onClick={vmazify}>Recursive Division (vertical skew)</a></li>\r\n                <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={hmazify}>Recursive Division (horizontal skew)</a></li>\r\n                <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={kruskalMazify}>Kruskal's Maze</a></li>\r\n                <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={primMazify}>Prims's Maze</a></li>\r\n                <li id='startButtonCreateMazeOne'><a href=\"#\" onClick={wallMazify}>Basic Random Maze</a></li>\r\n                <li id='startButtonCreateMazeWeights'><a href=\"#\" onClick={weightMazify}>Basic Weight Maze</a></li>\r\n            </ul>\r\n        </li>;\r\n        let weightAndWallOption = <li id='startButtonClearWalls'><a href=\"#\" onClick={clearWallsandWeights}>Clear Walls &amp; Weights</a></li>;\r\n        let addWeightOption = <li id='startButtonAddObject'><a href=\"#\" onClick={this.onWeightWallToggleClick}>Add {this.state.weightOrWall ? 'Wall' : 'Weight'}</a></li>;\r\n        if(this.state.isCanvas){\r\n            mazeOptions = <li className=\"dropdown\">\r\n                <a className=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Minimum Spanning Tree\r\n             <span className=\"caret\"></span></a>\r\n                <ul className=\"dropdown-menu\">\r\n                    <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={kruskalMST}>Kruskal's Algorithm</a></li>\r\n                    <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={primMST}>Prims's Algorithm</a></li>\r\n                </ul>\r\n            </li>;\r\n            weightAndWallOption = <li></li>;\r\n            addWeightOption = <li></li>;\r\n        }\r\n\r\n        return (\r\n            <div id='navbarDiv'>\r\n                <nav className=\"navbar navbar-inverse\">\r\n                    <div className=\"container-fluid\">\r\n                        <div className=\"navbar-header\">\r\n                            <a id=\"refreshButton\" className=\"navbar-brand\" href=\"#\">Graph Visualizer</a>\r\n                        </div>\r\n                        <ul className=\"nav navbar-nav\">\r\n                            <li className=\"dropdown\">\r\n                                <a className=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Algorithms\r\n             <span className=\"caret\"></span></a>\r\n                                <ul className=\"dropdown-menu\">\r\n                                    <li id='startButtonDijkstra'><a href=\"#\" onClick={this.dijkstraClick}>Dijkstra's Algorithm</a></li>\r\n                                    <li id='startButtonBFS'><a href=\"#\" onClick={this.bfsClick}>Breadth-first Search</a></li>\r\n                                    <li id='startButtonDFS'><a href=\"#\" onClick={this.dfsClick}>Depth-first Search</a></li>\r\n                                </ul>\r\n                            </li>\r\n                            {mazeOptions}\r\n                            {addWeightOption}\r\n                            <li id='startButtonStart'><button id=\"actualStartButton\" className=\"btn btn-default navbar-btn\" type=\"button\" onClick={this.onVisualizeClick}>Visualize {this.state.visualize}!</button></li>\r\n                            <li id='startButtonClearBoard'><a href=\"#\" onClick={resetGrid}>Clear Board</a></li>\r\n                            {weightAndWallOption}\r\n                            <li id='startButtonClearPath'><a href=\"#\" onClick={clearGrid}>Clear Path</a></li>\r\n                            <li id='startButtonAddObject'><a href=\"#\" onClick={this.toggleCanvas}>Switch to {this.state.isCanvas ? 'Grid' : 'Canvas'}</a></li>\r\n                        </ul>\r\n                    </div>\r\n                </nav>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Navbar;","function createNode(row, col, finishNode, startNode) {\r\n    const srow = startNode.row;\r\n    const scol = startNode.col;\r\n    const frow = finishNode.row;\r\n    const fcol = finishNode.col;\r\n    return {\r\n        row: row,\r\n        col: col,\r\n        isVisited: false,\r\n        isWall: false,\r\n        parent: null,\r\n        isNode: true,\r\n        isStart:\r\n            row === srow && col === scol,\r\n        isFinish:\r\n            row === frow && col === fcol,\r\n        weight: 1,\r\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\r\n    };\r\n}\r\n\r\n// assumed rowNum ans colNum are odd\r\n\r\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\r\n    const grid = [];\r\n    for (let r = 0; r < rowNum; r++) {\r\n        const row = [];\r\n        for (let c = 0; c < colNum; c++) {\r\n            const newNode = createNode(r, c, finishNode, startNode);\r\n            if ((r % 2 == 0 || c % 2 == 0)) newNode.isWall = true;\r\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\r\n            row.push(newNode);\r\n        }\r\n        grid.push(row);\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction getChildren(node, grid) {\r\n    const { row, col } = node;\r\n    const childElements = [];\r\n    const hChildDirections = [[2, 0], [-2, 0]];\r\n    const vChildDirections = [[0, 2], [0, -2]];\r\n    // const childDirections = [[2,0],[0,2],[-2,0],[0,-2]];\r\n\r\n    const vChildElements = [];\r\n    vChildDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited) {\r\n                // child.isVisited = true;\r\n                vChildElements.push(child);\r\n            }\r\n        }\r\n    });\r\n    childElements.push(vChildElements);\r\n\r\n    const hChildElements = [];\r\n    hChildDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited) {\r\n                // child.isVisited = true;\r\n                hChildElements.push(child);\r\n            }\r\n        }\r\n    });\r\n    childElements.push(hChildElements);\r\n\r\n    return childElements;\r\n}\r\n\r\nfunction removeWall(nodeA, nodeB, grid) {\r\n\r\n    const rowA = nodeA.row;\r\n    const colA = nodeA.col;\r\n    const rowB = nodeB.row;\r\n    const colB = nodeB.col;\r\n\r\n    const r = Math.floor((rowA + rowB) / 2);\r\n    const c = Math.floor((colA + colB) / 2);\r\n\r\n    grid[r][c].isWall = false;\r\n    return;\r\n    // return grid[r][c];\r\n\r\n}\r\n\r\nexport function horizontalSkewMaze(rowNum, colNum, startNode, finishNode) {\r\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\r\n    // console.log(grid);\r\n\r\n    let currentNode = grid[1][1];\r\n    let dfsStack = [currentNode];\r\n\r\n    while (dfsStack.length) {\r\n        const childElements = getChildren(currentNode, grid);\r\n        if (childElements[0].length || childElements[1].length) {\r\n            const random1 = Math.floor(Math.random() * 4);\r\n            if (random1 !== 3 && childElements[0].length) {\r\n                const random = Math.floor(Math.random() * childElements[0].length);\r\n                removeWall(currentNode, childElements[0][random], grid);\r\n                currentNode = childElements[0][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else if (random1 === 3 && childElements[1].length) {\r\n                const random = Math.floor(Math.random() * childElements[1].length);\r\n                removeWall(currentNode, childElements[1][random], grid);\r\n                currentNode = childElements[1][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else if (childElements[1].length) {\r\n                const random = Math.floor(Math.random() * childElements[1].length);\r\n                removeWall(currentNode, childElements[1][random], grid);\r\n                currentNode = childElements[1][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else {\r\n                const random = Math.floor(Math.random() * childElements[0].length);\r\n                // console.log(currentNode, childElements[random], removeWall(currentNode, childElements[random]));\r\n                removeWall(currentNode, childElements[0][random], grid);\r\n                currentNode = childElements[0][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n        }\r\n        else {\r\n            currentNode = dfsStack.pop();\r\n        }\r\n    }\r\n    grid.forEach(row => {\r\n        row.forEach(node => {\r\n            node.isVisited = false;\r\n        });\r\n    });\r\n    // console.log(grid);\r\n    return grid;\r\n}","function createNode(row, col, finishNode, startNode) {\r\n    const srow = startNode.row;\r\n    const scol = startNode.col;\r\n    const frow = finishNode.row;\r\n    const fcol = finishNode.col;\r\n    return {\r\n        row: row,\r\n        col: col,\r\n        isVisited: false,\r\n        isWall: false,\r\n        parent: null,\r\n        isNode: true,\r\n        isStart:\r\n            row === srow && col === scol,\r\n        isFinish:\r\n            row === frow && col === fcol,\r\n        weight: 1,\r\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\r\n    };\r\n}\r\n\r\n// assumed rowNum ans colNum are odd\r\n\r\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\r\n    const grid = [];\r\n    for (let r = 0; r < rowNum; r++) {\r\n        const row = [];\r\n        for (let c = 0; c < colNum; c++) {\r\n            const newNode = createNode(r, c, finishNode, startNode);\r\n            if ((r % 2 == 0 || c % 2 == 0)) newNode.isWall = true;\r\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\r\n            row.push(newNode);\r\n        }\r\n        grid.push(row);\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction getChildren(node, grid) {\r\n    const { row, col } = node;\r\n    const childElements = [];\r\n    const hChildDirections = [[2, 0], [-2, 0]];\r\n    const vChildDirections = [[0, 2], [0, -2]];\r\n    // const childDirections = [[2,0],[0,2],[-2,0],[0,-2]];\r\n\r\n    const hChildElements = [];\r\n    hChildDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited) {\r\n                // child.isVisited = true;\r\n                hChildElements.push(child);\r\n            }\r\n        }\r\n    });\r\n    childElements.push(hChildElements);\r\n\r\n    const vChildElements = [];\r\n    vChildDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited) {\r\n                // child.isVisited = true;\r\n                vChildElements.push(child);\r\n            }\r\n        }\r\n    });\r\n    childElements.push(vChildElements);\r\n    return childElements;\r\n}\r\n\r\nfunction removeWall(nodeA, nodeB, grid) {\r\n\r\n    const rowA = nodeA.row;\r\n    const colA = nodeA.col;\r\n    const rowB = nodeB.row;\r\n    const colB = nodeB.col;\r\n\r\n    const r = Math.floor((rowA + rowB) / 2);\r\n    const c = Math.floor((colA + colB) / 2);\r\n\r\n    grid[r][c].isWall = false;\r\n    return;\r\n    // return grid[r][c];\r\n\r\n}\r\n\r\nexport function verticalSkewMaze(rowNum, colNum, startNode, finishNode) {\r\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\r\n    // console.log(grid);\r\n\r\n    let currentNode = grid[1][1];\r\n    let dfsStack = [currentNode];\r\n\r\n    while (dfsStack.length) {\r\n        const childElements = getChildren(currentNode, grid);\r\n        if (childElements[0].length || childElements[1].length) {\r\n            const random1 = Math.floor(Math.random() * 4);\r\n            if (random1 !== 3 && childElements[0].length) {\r\n                const random = Math.floor(Math.random() * childElements[0].length);\r\n                removeWall(currentNode, childElements[0][random], grid);\r\n                currentNode = childElements[0][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else if (random1 === 3 && childElements[1].length) {\r\n                const random = Math.floor(Math.random() * childElements[1].length);\r\n                removeWall(currentNode, childElements[1][random], grid);\r\n                currentNode = childElements[1][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else if (childElements[1].length) {\r\n                const random = Math.floor(Math.random() * childElements[1].length);\r\n                removeWall(currentNode, childElements[1][random], grid);\r\n                currentNode = childElements[1][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else {\r\n                const random = Math.floor(Math.random() * childElements[0].length);\r\n                // console.log(currentNode, childElements[random], removeWall(currentNode, childElements[random]));\r\n                removeWall(currentNode, childElements[0][random], grid);\r\n                currentNode = childElements[0][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n        }\r\n        else {\r\n            currentNode = dfsStack.pop();\r\n        }\r\n    }\r\n    grid.forEach(row => {\r\n        row.forEach(node => {\r\n            node.isVisited = false;\r\n        });\r\n    });\r\n    // console.log(grid);\r\n    return grid;\r\n}\r\n\r\n","export default class DisjointSetItem {\r\n    /**\r\n     * @param {*} value\r\n     * @param {function(value: *)} [keyCallback]\r\n     */\r\n    constructor(value, keyCallback) {\r\n        this.value = value;\r\n        this.keyCallback = keyCallback;\r\n        /** @var {DisjointSetItem} this.parent */\r\n        this.parent = null;\r\n        this.children = {};\r\n    }\r\n\r\n    /**\r\n     * @return {*}\r\n     */\r\n    getKey() {\r\n        // Allow user to define custom key generator.\r\n        if (this.keyCallback) {\r\n            return this.keyCallback(this.value);\r\n        }\r\n\r\n        // Otherwise use value as a key by default.\r\n        return this.value;\r\n    }\r\n\r\n    /**\r\n     * @return {DisjointSetItem}\r\n     */\r\n    getRoot() {\r\n        return this.isRoot() ? this : this.parent.getRoot();\r\n    }\r\n\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    isRoot() {\r\n        return this.parent === null;\r\n    }\r\n\r\n    /**\r\n     * Rank basically means the number of all ancestors.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getRank() {\r\n        if (this.getChildren().length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        let rank = 0;\r\n\r\n        /** @var {DisjointSetItem} child */\r\n        this.getChildren().forEach((child) => {\r\n            // Count child itself.\r\n            rank += 1;\r\n\r\n            // Also add all children of current child.\r\n            rank += child.getRank();\r\n        });\r\n\r\n        return rank;\r\n    }\r\n\r\n    /**\r\n     * @return {DisjointSetItem[]}\r\n     */\r\n    getChildren() {\r\n        return Object.values(this.children);\r\n    }\r\n\r\n    /**\r\n     * @param {DisjointSetItem} parentItem\r\n     * @param {boolean} forceSettingParentChild\r\n     * @return {DisjointSetItem}\r\n     */\r\n    setParent(parentItem, forceSettingParentChild = true) {\r\n        this.parent = parentItem;\r\n        if (forceSettingParentChild) {\r\n            parentItem.addChild(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param {DisjointSetItem} childItem\r\n     * @return {DisjointSetItem}\r\n     */\r\n    addChild(childItem) {\r\n        this.children[childItem.getKey()] = childItem;\r\n        childItem.setParent(this, false);\r\n\r\n        return this;\r\n    }\r\n}","import DisjointSetItem from './disjointSetItem';\r\n\r\nexport default class DisjointSet {\r\n    /**\r\n     * @param {function(value: *)} [keyCallback]\r\n     */\r\n    constructor(keyCallback) {\r\n        this.keyCallback = keyCallback;\r\n        this.items = {};\r\n    }\r\n\r\n    /**\r\n     * @param {*} itemValue\r\n     * @return {DisjointSet}\r\n     */\r\n    makeSet(itemValue) {\r\n        const disjointSetItem = new DisjointSetItem(itemValue, this.keyCallback);\r\n\r\n        if (!this.items[disjointSetItem.getKey()]) {\r\n            // Add new item only in case if it not presented yet.\r\n            this.items[disjointSetItem.getKey()] = disjointSetItem;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Find set representation node.\r\n     *\r\n     * @param {*} itemValue\r\n     * @return {(string|null)}\r\n     */\r\n    find(itemValue) {\r\n        const templateDisjointItem = new DisjointSetItem(itemValue, this.keyCallback);\r\n\r\n        // Try to find item itself;\r\n        const requiredDisjointItem = this.items[templateDisjointItem.getKey()];\r\n\r\n        if (!requiredDisjointItem) {\r\n            return null;\r\n        }\r\n\r\n        return requiredDisjointItem.getRoot().getKey();\r\n    }\r\n\r\n    /**\r\n     * Union by rank.\r\n     *\r\n     * @param {*} valueA\r\n     * @param {*} valueB\r\n     * @return {DisjointSet}\r\n     */\r\n    union(valueA, valueB) {\r\n        const rootKeyA = this.find(valueA);\r\n        const rootKeyB = this.find(valueB);\r\n\r\n        if (rootKeyA === null || rootKeyB === null) {\r\n            throw new Error('One or two values are not in sets');\r\n        }\r\n\r\n        if (rootKeyA === rootKeyB) {\r\n            // In case if both elements are already in the same set then just return its key.\r\n            return this;\r\n        }\r\n\r\n        const rootA = this.items[rootKeyA];\r\n        const rootB = this.items[rootKeyB];\r\n\r\n        if (rootA.getRank() < rootB.getRank()) {\r\n            // If rootB's tree is bigger then make rootB to be a new root.\r\n            rootB.addChild(rootA);\r\n\r\n            return this;\r\n        }\r\n\r\n        // If rootA's tree is bigger then make rootA to be a new root.\r\n        rootA.addChild(rootB);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param {*} valueA\r\n     * @param {*} valueB\r\n     * @return {boolean}\r\n     */\r\n    inSameSet(valueA, valueB) {\r\n        const rootKeyA = this.find(valueA);\r\n        const rootKeyB = this.find(valueB);\r\n\r\n        if (rootKeyA === null || rootKeyB === null) {\r\n            throw new Error('One or two values are not in sets');\r\n        }\r\n\r\n        return rootKeyA === rootKeyB;\r\n    }\r\n}","// with data structure\r\n// working fine\r\nimport DisjointSet from '../../Data Structures/disjointSet';\r\nlet disjointSet = new DisjointSet((node)=>{\r\n    return node.index;\r\n});\r\nfunction createNode(row, col, finishNode, startNode) {\r\n    const srow = startNode.row;\r\n    const scol = startNode.col;\r\n    const frow = finishNode.row;\r\n    const fcol = finishNode.col;\r\n    return {\r\n        row: row,\r\n        col: col,\r\n        isVisited: false,\r\n        isWall: false,\r\n        parent: null,\r\n        isNode: true,\r\n        isStart:\r\n            row === srow && col === scol,\r\n        isFinish:\r\n            row === frow && col === fcol,\r\n        weight: 1,\r\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\r\n        index: -1,\r\n    };\r\n}\r\nlet hWallSet = [];\r\nlet vWallSet = [];\r\nlet rootNodeIndex = [];\r\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\r\n    disjointSet = new DisjointSet((node) => {\r\n        return node.index;\r\n    });\r\n    hWallSet = [];\r\n    vWallSet = [];\r\n    const grid = [];\r\n    let i = 0;\r\n    for (let r = 0; r < rowNum; r++) {\r\n        const row = [];\r\n        for (let c = 0; c < colNum; c++) {\r\n            const newNode = createNode(r, c, finishNode, startNode);\r\n            if ((r % 2 == 0 || c % 2 == 0)) {\r\n                newNode.isWall = true;\r\n                if (c % 2 === 0 && r % 2 === 1 && c > 0 && c < colNum - 1) {\r\n                    hWallSet.push(newNode);\r\n                }\r\n                else if (r % 2 === 0 && c % 2 === 1 && r > 0 && r < rowNum - 1) {\r\n                    vWallSet.push(newNode);\r\n                }\r\n            }\r\n            else {\r\n                newNode.index = i;\r\n                // rootNodeIndex.push(i);\r\n                i++;\r\n                disjointSet.makeSet(newNode);\r\n            }\r\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\r\n            row.push(newNode);\r\n        }\r\n        grid.push(row);\r\n    }\r\n    return grid;\r\n}\r\nexport function kruskalMaze(rowNum, colNum, startNode, finishNode) {\r\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\r\n    // console.log(hWallSet.length);\r\n    // console.log(vWallSet.length);\r\n    while(hWallSet.length || vWallSet.length) {\r\n        const random1 = Math.floor(Math.random() * 2);\r\n        if (random1 && hWallSet.length) {\r\n            const random2 = Math.floor(Math.random() * hWallSet.length);\r\n            const node = hWallSet[random2];\r\n            const { row, col } = node;\r\n            const neighborNodeRight = grid[row][col + 1];\r\n            const neighborNodeLeft = grid[row][col - 1];\r\n            if (!disjointSet.inSameSet(neighborNodeLeft,neighborNodeRight)) {\r\n                node.isWall = false;\r\n                disjointSet.union(neighborNodeLeft,neighborNodeRight);\r\n            }\r\n            hWallSet.splice(random2, 1);\r\n        }\r\n        else if (!random1 && vWallSet.length) {\r\n            const random2 = Math.floor(Math.random() * vWallSet.length);\r\n            const node = vWallSet[random2];\r\n            const { row, col } = node;\r\n            const neighborNodeRight = grid[row + 1][col];\r\n            const neighborNodeLeft = grid[row - 1][col];\r\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\r\n                node.isWall = false;\r\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\r\n            }\r\n            vWallSet.splice(random2, 1);\r\n        }\r\n        else if (hWallSet.length) {\r\n            const random2 = Math.floor(Math.random() * hWallSet.length);\r\n            const node = hWallSet[random2];\r\n            const { row, col } = node;\r\n            const neighborNodeRight = grid[row][col + 1];\r\n            const neighborNodeLeft = grid[row][col - 1];\r\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\r\n                node.isWall = false;\r\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\r\n            }\r\n            hWallSet.splice(random2, 1);\r\n        }\r\n        else if (vWallSet.length) {\r\n            const random2 = Math.floor(Math.random() * vWallSet.length);\r\n            const node = vWallSet[random2];\r\n            const { row, col } = node;\r\n            const neighborNodeRight = grid[row + 1][col];\r\n            const neighborNodeLeft = grid[row - 1][col];\r\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\r\n                node.isWall = false;\r\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\r\n            }\r\n            vWallSet.splice(random2, 1);\r\n        }\r\n    }\r\n    // console.log(grid);\r\n    return grid;\r\n}","import DisjointSet from '../../Data Structures/disjointSet';\r\nlet disjointSet = new DisjointSet((node) => {\r\n    return node.index;\r\n});\r\n\r\nfunction createNode(row, col, finishNode, startNode) {\r\n    const srow = startNode.row;\r\n    const scol = startNode.col;\r\n    const frow = finishNode.row;\r\n    const fcol = finishNode.col;\r\n    return {\r\n        row: row,\r\n        col: col,\r\n        isVisited: false,\r\n        isWall: false,\r\n        parent: null,\r\n        isNode: true,\r\n        isStart:\r\n            row === srow && col === scol,\r\n        isFinish:\r\n            row === frow && col === fcol,\r\n        weight: 1,\r\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\r\n        index: -1,\r\n    };\r\n}\r\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\r\n    disjointSet = new DisjointSet((node) => {\r\n        return node.index;\r\n    });\r\n    const grid = [];\r\n    let i = 0;\r\n    for (let r = 0; r < rowNum; r++) {\r\n        const row = [];\r\n        for (let c = 0; c < colNum; c++) {\r\n            const newNode = createNode(r, c, finishNode, startNode);\r\n            if ((r % 2 == 0 || c % 2 == 0)) {\r\n                newNode.isWall = true;\r\n            }\r\n            else {\r\n                newNode.index = i;\r\n                i++;\r\n                disjointSet.makeSet(newNode);\r\n            }\r\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\r\n            row.push(newNode);\r\n        }\r\n        grid.push(row);\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction getChildren(node,grid) {\r\n    const childDirection = [[2,0],[0,2],[-2,0],[0,-2]];\r\n    const children = [];\r\n    const {row,col} = node;\r\n    childDirection.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if(childRow > 0 && childCol > 0 && childRow < grid.length && childCol < grid[0].length){\r\n            const childNode = grid[childRow][childCol];\r\n            children.push(childNode);            \r\n        }\r\n    });\r\n    return children;\r\n}\r\nfunction removeWall(nodeA, nodeB, grid) {\r\n\r\n    const rowA = nodeA.row;\r\n    const colA = nodeA.col;\r\n    const rowB = nodeB.row;\r\n    const colB = nodeB.col;\r\n\r\n    const r = Math.floor((rowA + rowB) / 2);\r\n    const c = Math.floor((colA + colB) / 2);\r\n\r\n    grid[r][c].isWall = false;\r\n    return;\r\n}\r\nfunction unionJoint(node,currentNode,grid){\r\n    const children = getChildren(node,grid);\r\n    children.forEach(child => {\r\n        if(disjointSet.inSameSet(child,currentNode) && !disjointSet.inSameSet(currentNode,node))\r\n        {\r\n            removeWall(child,node,grid);\r\n            disjointSet.union(currentNode, node);\r\n        }\r\n    });\r\n    return;\r\n}\r\nexport function primMaze(rowNum, colNum, startNode, finishNode) {\r\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\r\n\r\n    let currentNode = grid[1][1];\r\n    const edgeQueue= [grid[3][1],grid[1][3]];\r\n    grid[3][1].isVisited = true;\r\n    grid[1][3].isVisited = true;\r\n    while(edgeQueue.length)\r\n    {\r\n        const random = Math.floor(Math.random()*edgeQueue.length);\r\n        // removeWall(currentNode,edgeQueue[random],grid);\r\n        unionJoint(edgeQueue[random],currentNode,grid);\r\n        currentNode =  edgeQueue[random];\r\n        // console.log(currentNode);\r\n        const children = getChildren(currentNode,grid);\r\n        if(children.length){\r\n            children.forEach(child=>{\r\n                if(!child.isVisited){\r\n                    edgeQueue.push(child);\r\n                    child.isVisited = true;\r\n                }\r\n            });\r\n        }\r\n        edgeQueue.splice(random,1);\r\n    }\r\n    grid.forEach(row=>{\r\n        row.forEach(node=>{\r\n            node.isVisited = false;\r\n        });\r\n    });\r\n    return grid;\r\n}","import React from 'react';\r\nimport Node from './Node/Node';\r\nimport './PathfindingVisualizer.css'\r\nimport { bfs } from './Algorithms/bfs'\r\nimport { dfs } from './Algorithms/dfs'\r\nimport { dijkstra } from './Algorithms/dijkstra'\r\nimport { maze } from './Mazes/maze'\r\nimport { weightMaze } from './Mazes/weightMaze'\r\nimport { wallMaze } from './Mazes/wallMaze'\r\nimport Navbar from '../Navbar';\r\nimport {horizontalSkewMaze} from './Mazes/hSkewMaze';\r\nimport { verticalSkewMaze } from './Mazes/vSkewMaze';\r\nimport { kruskalMaze } from './Mazes/kruskalsMaze1';\r\nimport {primMaze} from './Mazes/primsMaze';\r\nclass PathfindingVisualizer extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            ROW_COUNT: 25,\r\n            COLUMN_COUNT: 35,\r\n            START_NODE_ROW: 5,\r\n            FINISH_NODE_ROW: 20,\r\n            START_NODE_COL: 5,\r\n            FINISH_NODE_COL: 30,\r\n            isRunning: false,\r\n            mouseIsPressed: false,\r\n            startNodePressed: false,\r\n            finishNodePressed: false,\r\n            navbarHeight: 0,\r\n            weightWallToggle:false,            \r\n        };\r\n\r\n    }\r\n\r\n    navbarHeight = (height) => {\r\n        const navbarHeight = height;\r\n        this.setState({ navbarHeight });\r\n    }\r\n\r\n    toggleIsRunning = () => {\r\n        let isRunning = !this.state.isRunning;\r\n        this.setState({ isRunning });\r\n    }\r\n    toggleWeightWallToggle = () =>{\r\n        const weightWallToggle = !this.state.weightWallToggle;\r\n        this.setState({weightWallToggle});\r\n    }\r\n\r\n    getInitialGrid = (\r\n        rowCount = this.state.ROW_COUNT,\r\n        colCount = this.state.COLUMN_COUNT,\r\n    ) => {\r\n        const initialGrid = [];\r\n        for (let row = 0; row < rowCount; row++) {\r\n            const currentRow = [];\r\n            for (let col = 0; col < colCount; col++) {\r\n                currentRow.push(this.createNode(row, col));\r\n            }\r\n            initialGrid.push(currentRow);\r\n        }\r\n        return initialGrid;\r\n    };\r\n\r\n    createNode = (row, col) => {\r\n        return {\r\n            row,\r\n            col,\r\n            isStart:\r\n                row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n            isFinish:\r\n                row === this.state.FINISH_NODE_ROW &&\r\n                col === this.state.FINISH_NODE_COL,\r\n            isVisited: false,\r\n            isWall: false,\r\n            parent: null,\r\n            isNode: true,\r\n            weight: 1,\r\n            costFromSource: (row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL) ? 0 : Number.POSITIVE_INFINITY,\r\n            // extraClassName:\"\",\r\n        };\r\n    };\r\n\r\n    clearGrid = () => {\r\n        if (!this.state.isRunning) {\r\n            let grid = this.state.grid;\r\n\r\n            for (const row of grid) {\r\n                for (const node of row) {\r\n                    if (!node.isStart && !node.isFinish && !node.isWall) {\r\n                        document.getElementById(\r\n                            `node-${node.row}-${node.col}`\r\n                        ).className = 'node';\r\n                        node.isVisited = false;\r\n                        node.parent = null;\r\n                        node.costFromSource = Number.POSITIVE_INFINITY;\r\n                        // nodeClassName = 'node';\r\n                    }\r\n                    else if (node.isStart || node.isFinish) {\r\n                        node.parent = null;\r\n                        node.isVisited = false;\r\n                        if(node.isStart) node.costFromSource = 0;\r\n                        else node.costFromSource = Number.POSITIVE_INFINITY;\r\n                    }\r\n                }\r\n            }\r\n            this.setState({ grid });\r\n            // console.log(grid);\r\n        }\r\n    }\r\n    clearWallsandWeights = () => {\r\n        if (!this.state.isRunning) {\r\n            let grid = this.state.grid;\r\n\r\n            for (const row of grid) {\r\n                for (const node of row) {\r\n                    if (node.isWall ) {\r\n                        document.getElementById(\r\n                            `node-${node.row}-${node.col}`\r\n                        ).className = 'node';\r\n                        node.isVisited = false;\r\n                        node.parent = null;\r\n                        node.isWall = false;\r\n                        node.costFromSource = Number.POSITIVE_INFINITY;\r\n                        // nodeClassName = 'node';\r\n                    }\r\n                    if (node.weight !==1)\r\n                    {\r\n                        node.weight = 1;\r\n                        node.costFromSource = node.isStart ? 0: Number.POSITIVE_INFINITY;\r\n                    }\r\n                }\r\n            }\r\n            this.setState({ grid });\r\n\r\n            // console.log(grid);\r\n        }\r\n    }\r\n    resetGrid = () => {\r\n        if (!this.state.isRunning) {\r\n            let grid = this.state.grid;\r\n\r\n            for (const row of grid) {\r\n                for (const node of row) {\r\n                    if (!node.isStart && !node.isFinish) {\r\n                        document.getElementById(\r\n                            `node-${node.row}-${node.col}`\r\n                        ).className = 'node';\r\n                        node.isVisited = false;\r\n                        node.parent = null;\r\n                        node.isWall = false;\r\n                        // nodeClassName = 'node';\r\n                    }\r\n                    else if (node.isStart || node.isFinish) {\r\n                        node.parent = null;\r\n                        node.isVisited = false;\r\n                    }\r\n                }\r\n            }\r\n            this.setState({ grid });\r\n            // console.log(grid);\r\n        }\r\n    }\r\n\r\n    onCellDown = (row, col) => {\r\n        if (!this.state.isRunning && !this.state.weightWallToggle) {\r\n\r\n            const grid = this.state.grid;\r\n            if (!this.state.mouseIsPressed) {\r\n                const mouseIsPressed = !this.state.mouseIsPressed;\r\n                this.setState({ mouseIsPressed });\r\n                const currentNode = grid[row][col];\r\n                if (!currentNode.isStart && !currentNode.isFinish) {\r\n                    if (currentNode.isWall) {\r\n                        document.getElementById(`node-${row}-${col}`).className = 'node';\r\n                        currentNode.isWall = false;\r\n                    }\r\n                    else {\r\n                        document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\r\n                        currentNode.isWall = true;\r\n                        currentNode.weight=1;\r\n                    }\r\n                }\r\n                else if (currentNode.isStart) {\r\n                    const startNodePressed = !this.state.startNodePressed;\r\n                    this.setState({ startNodePressed });\r\n                    document.getElementById(`node-${row}-${col}`).className = 'node';\r\n                    currentNode.isStart = false;\r\n                }\r\n                else if (currentNode.isFinish) {\r\n                    const finishNodePressed = !this.state.finishNodePressed;\r\n                    this.setState({ finishNodePressed });\r\n                    document.getElementById(`node-${row}-${col}`).className = 'node' ;\r\n                    currentNode.isFinish = false;\r\n                }\r\n            }\r\n        }\r\n        else if(!this.state.isRunning && this.state.weightWallToggle)\r\n        {\r\n            const grid = this.state.grid;\r\n            const currentNode = grid[row][col];\r\n            if(!currentNode.isWall){\r\n                currentNode.weight = currentNode.weight+1;\r\n            }\r\n        }\r\n    }\r\n    onCellEnter = (row, col) => {\r\n        if (!this.state.isRunning && this.state.mouseIsPressed) {\r\n            const grid = this.state.grid;\r\n            const currentNode = grid[row][col];\r\n            if (!currentNode.isStart && !currentNode.isFinish && !this.state.startNodePressed && !this.state.finishNodePressed) {\r\n                document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\r\n                currentNode.isWall = true;\r\n                currentNode.weight = 1;\r\n            }\r\n            else if (this.state.startNodePressed) {\r\n                const START_NODE_ROW = row;\r\n                const START_NODE_COL = col;\r\n                this.setState({ START_NODE_ROW, START_NODE_COL });\r\n                document.getElementById(`node-${row}-${col}`).className = 'node node-start';\r\n            }\r\n            else if (this.state.finishNodePressed) {\r\n                const FINISH_NODE_ROW = row;\r\n                const FINISH_NODE_COL = col;\r\n                this.setState({ FINISH_NODE_ROW, FINISH_NODE_COL });\r\n                document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\r\n            }\r\n\r\n        }\r\n    }\r\n    onCellLeave = (row, col) => {\r\n        const grid = this.state.grid;\r\n        if (this.state.startNodePressed) {\r\n            if (!grid[row][col].isFinish && !grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node';\r\n            else if (grid[row][col].isFinish) document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\r\n            else if (grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\r\n        }\r\n        else if (this.state.finishNodePressed) {\r\n            if (!grid[row][col].isStart && !grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node';\r\n            else if (grid[row][col].isStart) document.getElementById(`node-${row}-${col}`).className = 'node node-start';\r\n            else if (grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\r\n        }\r\n    }\r\n    onCellRelease = () => {\r\n        const mouseIsPressed = false;\r\n        const grid = this.state.grid;\r\n        if (this.state.startNodePressed) {\r\n            const row = this.state.START_NODE_ROW;\r\n            const col = this.state.START_NODE_COL;\r\n            document.getElementById(`node-${row}-${col}`).className = 'node node-start';\r\n            grid[row][col].isStart = true;\r\n            grid[row][col].isWall = false;\r\n        }\r\n        else if (this.state.finishNodePressed) {\r\n            const row = this.state.FINISH_NODE_ROW;\r\n            const col = this.state.FINISH_NODE_COL;\r\n            document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\r\n            grid[row][col].isFinish = true;\r\n            grid[row][col].isWall = false;\r\n        }\r\n        const startNodePressed = false;\r\n        const finishNodePressed = false;\r\n        this.setState({ mouseIsPressed, startNodePressed, finishNodePressed, grid });\r\n    }\r\n\r\n\r\n\r\n    componentWillMount = () => {\r\n        // console.log(\"required\", this.state.navbarHeight);\r\n        const ROW_COUNT = 2 * Math.floor(Math.floor((document.documentElement.clientHeight - this.state.navbarHeight) / 25) / 2) - 3;\r\n        const COLUMN_COUNT = 2 * Math.floor(Math.floor(document.documentElement.clientWidth / 25) / 2) - 1;\r\n        const START_NODE_ROW = Math.floor(ROW_COUNT / 2);\r\n        const FINISH_NODE_ROW = Math.floor(ROW_COUNT / 2);\r\n        const START_NODE_COL = Math.floor(COLUMN_COUNT / 4);\r\n        const FINISH_NODE_COL = Math.floor(3 * COLUMN_COUNT / 4);\r\n        this.setState({ ROW_COUNT, COLUMN_COUNT, START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL });\r\n    }\r\n    componentDidMount = () => {\r\n        const grid = this.getInitialGrid();\r\n        this.setState({ grid });\r\n        console.log(\"required\", this.state.navbarHeight);\r\n        // console.log(grid);\r\n    }\r\n\r\n\r\n\r\n    visualize(algo) {\r\n        if (!this.state.isRunning) {\r\n            this.clearGrid();\r\n            this.toggleIsRunning();\r\n            const { grid } = this.state;\r\n            const startNode =\r\n                grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n            const finishNode =\r\n                grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n            let visitedNodesInOrder;\r\n            switch (algo) {\r\n                case 'Dijkstra':\r\n                    visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n                    break;\r\n                // case 'AStar':\r\n                //     visitedNodesInOrder = AStar(grid, startNode, finishNode);\r\n                //     break;\r\n                case 'BFS':\r\n                    visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n                    break;\r\n                case 'DFS':\r\n                    visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n                    break;\r\n                default:\r\n                    // should never get here\r\n                    break;\r\n            }\r\n\r\n            // console.log(visitedNodesInOrder);\r\n            // console.log(grid);\r\n            const nodesInShortestPathOrder = this.getNodesInShortestPathOrder(finishNode);\r\n            nodesInShortestPathOrder.push('end');\r\n            this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n        }\r\n    }\r\n\r\n    animate(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if (i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    this.animateShortestPath(nodesInShortestPathOrder);\r\n                }, 2 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                const nodeClassName = document.getElementById(\r\n                    `node-${node.row}-${node.col}`,\r\n                ).className;\r\n                if (\r\n                    nodeClassName !== 'node node-start' &&\r\n                    nodeClassName !== 'node node-finish'\r\n                ) {\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = \r\n                        'node node-visited' ;\r\n                }\r\n            }, 2 * i);\r\n        }\r\n    }\r\n\r\n    /******************** Create path from start to finish ********************/\r\n    animateShortestPath(nodesInShortestPathOrder) {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n            if (nodesInShortestPathOrder[i] === 'end') {\r\n                setTimeout(() => {\r\n                    this.toggleIsRunning();\r\n                    // console.log(\"Completed\");\r\n                }, i * 50);\r\n            } else {\r\n                setTimeout(() => {\r\n                    const node = nodesInShortestPathOrder[i];\r\n                    const nodeClassName = document.getElementById(\r\n                        `node-${node.row}-${node.col}`,\r\n                    ).className;\r\n                    if (\r\n                        nodeClassName !== 'node node-start'&&\r\n                        nodeClassName !== 'node node-finish'\r\n                    ) {\r\n                        document.getElementById(`node-${node.row}-${node.col}`).className = \r\n                            'node node-shortest-path';\r\n                    }\r\n                }, i * 40);\r\n            }\r\n        }\r\n    }\r\n\r\n    getNodesInShortestPathOrder(finishNode) {\r\n        const nodesInShortestPathOrder = [];\r\n        let currentNode = finishNode;\r\n        while (currentNode !== null) {\r\n            nodesInShortestPathOrder.unshift(currentNode);\r\n            currentNode = currentNode.parent;\r\n        }\r\n        return nodesInShortestPathOrder;\r\n    }\r\n\r\n    mazify = () => {\r\n        if (!this.state.isRunning) {\r\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n            const grid = maze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\r\n            this.setState({ grid });\r\n        }\r\n    }\r\n    hSkewMazify = ()=>{\r\n        if(!this.state.isRunning){\r\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n            const grid = horizontalSkewMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\r\n            this.setState({ grid });\r\n        }\r\n    }\r\n    vSkewMazify = () => {\r\n        if (!this.state.isRunning) {\r\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n            const grid = verticalSkewMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\r\n            this.setState({ grid });\r\n        }\r\n    }\r\n    kruskalMazify = () =>{\r\n        if (!this.state.isRunning) {\r\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n            const grid = kruskalMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\r\n            this.setState({ grid });\r\n        }\r\n    }\r\n    primMazify = () => {\r\n        if (!this.state.isRunning) {\r\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n            const grid = primMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\r\n            this.setState({ grid });\r\n        }\r\n    }\r\n    weightMazify = ()=>{\r\n        let grid = this.state.grid;\r\n        grid = weightMaze(grid);\r\n        this.setState({grid});\r\n    }\r\n    wallMazify = ()=>{\r\n        let grid = this.state.grid;\r\n        grid = wallMaze(grid);\r\n        this.setState({ grid });\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <Navbar\r\n                    dfs={() => this.visualize('DFS')}\r\n                    bfs={() => this.visualize('BFS')}\r\n                    dijkstra={() => this.visualize('Dijkstra')}\r\n                    clearGrid={() => this.clearGrid()}\r\n                    resetGrid={() => this.resetGrid()}\r\n                    clearWallsandWeights={() => this.clearWallsandWeights()}\r\n                    mazify={() => this.mazify()}\r\n                    hmazify={() => this.hSkewMazify()}\r\n                    vmazify={() => this.vSkewMazify()}\r\n                    kruskalMazify={() => this.kruskalMazify()}\r\n                    primMazify={() => this.primMazify()}\r\n                    weightMazify={()=>this.weightMazify()}\r\n                    wallMazify={() => this.wallMazify()}\r\n                    navbarHeight={this.navbarHeight}\r\n                    weightWallToggle={()=>this.toggleWeightWallToggle()}\r\n                    toggleCanvas = {()=> this.props.toggleCanvas()}\r\n                    isCanvas={this.props.isCanvas}\r\n                ></Navbar>\r\n                <table className=\"center grid-container\" >\r\n                    <tbody className=\"grid\">\r\n                        {\r\n                            this.state.grid.map((row, rowID) => {\r\n                                return (\r\n                                    <tr key={rowID} >\r\n                                        {\r\n                                            row.map((node, nodeID) => {\r\n                                                const { row, col, isFinish, isStart, isWall, weight } = node;\r\n\r\n                                                return (\r\n                                                    <Node\r\n                                                        key={nodeID}\r\n                                                        row={row}\r\n                                                        col={col}\r\n                                                        weight={weight}\r\n                                                        isFinish={isFinish}\r\n                                                        isStart={isStart}\r\n                                                        isWall={isWall}\r\n                                                        onMouseDown={(x, y) => { this.onCellDown(x, y) }}\r\n                                                        onMouseEnter={(x, y) => this.onCellEnter(x, y)}\r\n                                                        onMouseUp={() => this.onCellRelease()}\r\n                                                        onMouseLeave={(x, y) => this.onCellLeave(x, y)}\r\n                                                    ></Node>\r\n                                                );\r\n                                            })\r\n                                        }\r\n\r\n                                    </tr>\r\n                                );\r\n                            })\r\n                        }\r\n                    </tbody>\r\n                </table>\r\n                {/* <button onClick={() => this.visualize('BFS')}>BFS</button>\r\n                <button onClick={() => this.visualize('DFS')}>DFS</button>\r\n                <button onClick={() => this.clearGrid()}>Clear Gridd</button>\r\n                <button onClick={() => this.resetGrid()}>Reset Grid</button>\r\n                <button onClick={() => this.mazify()}>Maze</button> */}\r\n\r\n            </div>\r\n        )\r\n    }\r\n\r\n}\r\n\r\nexport default PathfindingVisualizer;\r\n","export function wallMaze(grid) {\r\n    grid.forEach(row => {\r\n        row.forEach(node => {\r\n            if (!node.isWall && !node.isStart && !node.isFinish) {\r\n                const random = Math.floor(Math.random()*4);\r\n                if(random===0)\r\n                {\r\n                    node.isWall = true;\r\n                    node.weight = 1;\r\n                }\r\n            }\r\n        });\r\n    });\r\n    return grid;\r\n}","// BFS\r\n\r\nexport function bfs (grid,startNode,finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    let bfsQueue = [startNode];\r\n    startNode.isVisited = true;\r\n    const childDirections = [[1,0],[0,1],[-1,0],[0,-1]] ;\r\n\r\n    while(bfsQueue.length)\r\n    {\r\n        const currentNode = bfsQueue.shift();\r\n        if (currentNode === finishNode) return visitedNodesInOrder;\r\n        visitedNodesInOrder.push(currentNode);\r\n        const {row,col} = currentNode;\r\n\r\n        childDirections.forEach(direction => {\r\n            let x = row + direction[0];\r\n            let y = col + direction[1];\r\n\r\n            if(x>=0 && y>=0 && x<grid.length && y<grid[0].length && !grid[x][y].isWall && !grid[x][y].isVisited)\r\n            {\r\n                bfsQueue.push(grid[x][y]);\r\n                grid[x][y].isVisited = true;\r\n                grid[x][y].parent = currentNode;\r\n            }\r\n        });\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\n","import React, { useRef, useState } from \"react\";\r\n\r\nexport const CanvasContext = React.createContext();\r\n\r\nexport const CanvasProvider = ({ children }) => {\r\n    const [isDrawing, setIsDrawing] = useState(false);\r\n\r\n    const [nodeDrawing, setNodeDrawing] = useState(true);\r\n    const [index,setIndex] = useState(0);\r\n    const canvasRef = useRef(null);\r\n    const contextRef = useRef(null);\r\n\r\n    const prepareCanvas = (height, width) => {\r\n        const canvas = canvasRef.current\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        canvas.style.width = `${width}px`;\r\n        canvas.style.height = `${height}px`;\r\n\r\n        const context = canvas.getContext(\"2d\");\r\n        context.lineCap = \"round\";\r\n        context.strokeStyle = \"black\";\r\n        context.lineWidth = 1;\r\n        contextRef.current = context;\r\n    };\r\n\r\n    const toggleNodeDrawing = () => {\r\n        setNodeDrawing(!nodeDrawing);\r\n    }\r\n\r\n    const [nodesOfGraph, pushNode] = useState([]);\r\n\r\n    const squareDistance = (node, x, y) => {\r\n        return Math.pow(node.centerX - x, 2) + Math.pow(node.centerY - y, 2);\r\n    }\r\n\r\n    const [startNode, setStartNode] = useState(null);\r\n    let currentCoordinates = null;\r\n    const whichNode = (x, y) => {\r\n        let node = null;\r\n        for (let i = 0; i < nodesOfGraph.length; i++) {\r\n            if (squareDistance(nodesOfGraph[i], x, y) <= 1600) {\r\n                node = nodesOfGraph[i];\r\n                return node;\r\n            }\r\n        }\r\n        return node;\r\n    }\r\n\r\n    const writeText = (info, style = {}) => {\r\n        const canvas = canvasRef.current;\r\n        const ctx = canvas.getContext(\"2d\");\r\n        const { text, x, y } = info;\r\n        const { fontSize = 20, fontFamily = 'Arial', color = 'black', textAlign = 'left', textBaseline = 'top' } = style;\r\n\r\n        ctx.beginPath();\r\n        ctx.font = fontSize + 'px ' + fontFamily;\r\n        ctx.textAlign = textAlign;\r\n        ctx.textBaseline = textBaseline;\r\n        ctx.fillStyle = color;\r\n        ctx.fillText(text, x, y);\r\n        ctx.stroke();\r\n    }\r\n\r\n    const startDrawing = ({ nativeEvent }) => {\r\n        if (nodeDrawing) {\r\n            const { offsetX, offsetY } = nativeEvent;\r\n            if (whichNode(offsetX, offsetY)) return;\r\n\r\n            setIndex((prevIndex)=> prevIndex + 1);\r\n            const canvas = canvasRef.current;\r\n            const ctx = canvas.getContext(\"2d\");\r\n\r\n\r\n            ctx.beginPath();\r\n            ctx.arc(offsetX, offsetY, 20, 0, Math.PI * 2, false);\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n            \r\n            const node = {\r\n                centerX: offsetX,\r\n                centerY: offsetY,\r\n                id: index,\r\n                children: [],\r\n                isVisited:false,\r\n                parent:null,\r\n                costFromSource:Number.POSITIVE_INFINITY,\r\n            };\r\n            pushNode([...nodesOfGraph, node]);\r\n            writeText({text : `${node.id}`,x : node.centerX-10,y : node.centerY-10});\r\n        }\r\n        else {\r\n            if (!isDrawing) {\r\n                const { offsetX, offsetY } = nativeEvent;\r\n\r\n                const start = whichNode(offsetX, offsetY);\r\n                setStartNode(start);\r\n                // console.log(start);\r\n\r\n                if (start) {\r\n                    setIsDrawing(true);\r\n                    currentCoordinates = { x: offsetX, y: offsetY };\r\n                    contextRef.current.beginPath();\r\n                    contextRef.current.moveTo(offsetX, offsetY);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    const [currentEdgeWeight,setCurrentEdgeWeight] = useState(0);\r\n    const finishDrawing = () => {\r\n        if (!nodeDrawing) {\r\n\r\n            if (isDrawing && currentCoordinates) {\r\n                setIsDrawing(false);\r\n\r\n                const { x, y } = currentCoordinates;\r\n                const end = whichNode(x, y);\r\n                // console.log(end);\r\n\r\n                if (!end) {\r\n                    // dont draw the edge\r\n                    // dont push it into edges\r\n                    console.log(\"end node is null\");\r\n                    contextRef.current.closePath();\r\n                }\r\n                else if (end.id === startNode.id) {\r\n                    // dont draw the edge\r\n                    // dont push it into edges\r\n                    console.log(\"end node = start node\");\r\n                    contextRef.current.closePath();\r\n                }\r\n                else {\r\n                    contextRef.current.moveTo(startNode.centerX, startNode.centerY);\r\n                    contextRef.current.lineTo(end.centerX, end.centerY);\r\n                    contextRef.current.stroke();\r\n                    contextRef.current.closePath();\r\n                    \r\n                    let c =false;\r\n                    for(let i=0;i<startNode.children.length;i++){\r\n                        if(startNode.children[i].node === end){\r\n                            c = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(!c){\r\n                        const weight = currentEdgeWeight;\r\n                        const x = (startNode.centerX + end.centerX) / 2;\r\n                        const y = (startNode.centerY + end.centerY) / 2;\r\n                        startNode.children.push({ node: end, weight });\r\n                        end.children.push({ node: startNode, weight });\r\n                        writeText({ text: (weight?weight:''), x, y });\r\n                    }\r\n                }\r\n                currentCoordinates = null;\r\n                setStartNode(null);\r\n            }\r\n        }\r\n    };\r\n\r\n    const draw = ({ nativeEvent }) => {\r\n        const { offsetX, offsetY } = nativeEvent;\r\n        if (!nodeDrawing) {\r\n            if (isDrawing) {\r\n                currentCoordinates = { x: offsetX, y: offsetY };\r\n            }\r\n        }\r\n    };\r\n\r\n    const clearCanvas = () => {\r\n        const canvas = canvasRef.current;\r\n        const context = canvas.getContext(\"2d\");\r\n        context.fillStyle = \"white\";\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        pushNode([]);\r\n        setIndex(1);\r\n    }\r\n\r\n    return (\r\n        <CanvasContext.Provider\r\n            value={{\r\n                canvasRef,\r\n                contextRef,\r\n                prepareCanvas,\r\n                startDrawing,\r\n                finishDrawing,\r\n                clearCanvas,\r\n                draw,\r\n                toggleNodeDrawing,\r\n                nodeDrawing,\r\n                nodesOfGraph,\r\n                pushNode,\r\n                setIndex,\r\n                setCurrentEdgeWeight,\r\n            }}\r\n        >\r\n            {children}\r\n        </CanvasContext.Provider>\r\n    );\r\n};\r\n\r\n","import React, { useEffect, useContext, useLayoutEffect, useState } from \"react\";\r\nimport { CanvasContext } from \"./CanvasContext\";\r\n\r\nfunction CanvasBoard(props) {\r\n    const {\r\n        canvasRef,\r\n        prepareCanvas,\r\n        startDrawing,\r\n        finishDrawing,\r\n        draw,\r\n        toggleNodeDrawing,\r\n        nodeDrawing,\r\n        nodesOfGraph,\r\n        clearCanvas,\r\n        pushNode,\r\n        setIndex,\r\n        setCurrentEdgeWeight,\r\n    } = useContext(CanvasContext);\r\n\r\n    const emptyTheGraph = () => {\r\n        pushNode([]);\r\n        setIndex(1);\r\n    }\r\n\r\n    useEffect(() => {\r\n        prepareCanvas(props.height, props.width);\r\n        clearCanvas();\r\n        props.settingStartNode(null);\r\n        props.settingEndNode(null);\r\n    }, []);\r\n    const [startNode, setStartNode] = useState(0);\r\n    const [endNode, setEndNode] = useState(0);\r\n    useEffect(() => {\r\n        props.settingGraph(nodesOfGraph);\r\n        if (!startNode) props.settingStartNode((nodesOfGraph.length ? nodesOfGraph[0] : null));\r\n        if (!endNode) props.settingEndNode(nodesOfGraph.length ? nodesOfGraph[nodesOfGraph.length - 1] : null);\r\n        if (props.emptyGraphCall) {\r\n            emptyTheGraph();\r\n            props.toggleEmptyTheGraph();\r\n        }\r\n    }, [nodesOfGraph, props.emptyGraphCall]);\r\n\r\n\r\n\r\n    const startNodeUpdate = (event) => {\r\n        const startIndex = event.target.value;\r\n        setStartNode(startIndex);\r\n        if (startIndex != 0 && startIndex <= nodesOfGraph.length) props.settingStartNode(nodesOfGraph[startIndex - 1]);\r\n        else alert('Not a valid start node');\r\n    }\r\n    const endNodeUpdate = (event) => {\r\n        const endIndex = event.target.value;\r\n        setEndNode(endIndex);\r\n        if (endIndex != 0 && endIndex <= nodesOfGraph.length) props.settingEndNode(nodesOfGraph[endIndex - 1]);\r\n        else alert('Not a valid start node');\r\n    }\r\n\r\n///////////////////////////////////////// try doing without usingStates\r\n    const [weightNodeA,setWeightNodeA] = useState(0);\r\n    const [weightNodeB, setWeightNodeB] = useState(0);\r\n    const [weight,setWeight] = useState(0);\r\n    const weightNodeAUpdate = (event)=>{\r\n        const nodeIndex = event.target.value;\r\n        setWeightNodeA(nodeIndex);\r\n    }\r\n    const weightNodeBUpdate = (event) => {\r\n        const nodeIndex = event.target.value;\r\n        setWeightNodeB(nodeIndex);\r\n    }\r\n    const weightUpdate=(event)=>{\r\n        const weight=parseInt(event.target.value);\r\n        setWeight(weight);\r\n        setCurrentEdgeWeight(weight);\r\n    }\r\n    const writeText = (info, style = {}) => {\r\n        const canvas = canvasRef.current;\r\n        const ctx = canvas.getContext(\"2d\");\r\n        const { text, x, y } = info;\r\n        const { fontSize = 20, fontFamily = 'Arial', color = 'black', textAlign = 'left', textBaseline = 'top' } = style;\r\n\r\n        ctx.beginPath();\r\n        ctx.font = fontSize + 'px ' + fontFamily;\r\n        ctx.textAlign = textAlign;\r\n        ctx.textBaseline = textBaseline;\r\n        ctx.fillStyle = color;\r\n        ctx.fillText(text, x, y);\r\n        ctx.stroke();\r\n    }\r\n    const addWeightToEdge = () => {\r\n        const startId = weightNodeA;\r\n        const endId = weightNodeB;\r\n        const weightFinal = weight;\r\n        if(startId > 0 && endId>0 && startId<=nodesOfGraph.length && endId<=nodesOfGraph.length){\r\n            const startNode = nodesOfGraph[startId - 1];\r\n            const endNode = nodesOfGraph[endId - 1];\r\n            for (let i = 0; i < startNode.children.length; i++) {\r\n                let { node } = startNode.children[i];\r\n                if (node === endNode) {\r\n                    startNode.children[i].weight = weightFinal;\r\n                    for (let j = 0; j < endNode.children.length; j++) {\r\n                        let { node, weight } = endNode.children[j];\r\n                        if (node === startNode) {\r\n                            endNode.children[j].weight = weightFinal;\r\n                            const x = (startNode.centerX + endNode.centerX)/2;\r\n                            const y = (startNode.centerY + endNode.centerY)/2;\r\n                            writeText({text:weightFinal,x,y});\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        alert('No such edge exists');\r\n    }\r\n/////////////////////////////////////////////////////////////////////////\r\n    let edgeWeightInput = <div><a>Current edge weight</a>\r\n        <input id=\"edgeWeight\" onChange={weightUpdate} type=\"number\" value={weight} /></div>;\r\n    if(nodeDrawing){\r\n        edgeWeightInput = <div></div>\r\n    }\r\n    return (\r\n        <>\r\n            {/* <section id=\"canvas-container\"> */}\r\n            <div id=\"wrapper\" class=\"toggled\">\r\n                <div id=\"sidebar-wrapper\">\r\n                    <ul className=\"sidebar-nav\">\r\n                        <li className=\"sidebar-brand\"> <a href=\"#\"> Control Panel </a> </li>\r\n                        <li> \r\n                            <a href=\"#\" onClick={toggleNodeDrawing}>Add {nodeDrawing ? 'Edge' : 'Node'}</a> \r\n                            {edgeWeightInput}\r\n                        </li>\r\n                        <li>\r\n                            <a>Start Node</a>\r\n                            <input id=\"startValue\" type = \"number\" placeholder={nodesOfGraph.length ? '1' : '0'} onChange={startNodeUpdate} />\r\n                            <a>End Node</a>\r\n                            <input id=\"endValue\" type=\"number\" placeholder={nodesOfGraph.length} onChange={endNodeUpdate} />\r\n                        </li>\r\n                        <li>\r\n                            <a>Add Weight</a>\r\n                            <a>Start Node</a>\r\n                            <input onChange={weightNodeAUpdate} type=\"number\" value ={weightNodeA}/>\r\n                            <a>End Node</a>\r\n                            <input onChange={weightNodeBUpdate} type=\"number\" value = {weightNodeB}/>\r\n                            <a>Weight</a>\r\n                            <input id=\"edgeWeight\" onChange={weightUpdate} type=\"number\" value = {weight}/>\r\n                            <button onClick = {addWeightToEdge}>Submit</button>\r\n                        </li>\r\n                    </ul>\r\n                </div>\r\n            </div>\r\n            <canvas id='canvas'\r\n                className=\"centercanvas\"\r\n                onMouseDown={props.isRunning?()=>{}:startDrawing}\r\n                onMouseUp={props.isRunning ? () => { } :finishDrawing}\r\n                onMouseMove={draw}\r\n                ref={canvasRef}\r\n            ></canvas>\r\n\r\n            <button ></button>\r\n            <br></br>\r\n            {/* </section> */}\r\n        </>\r\n    )\r\n}\r\n\r\nexport default CanvasBoard;","// BFS\r\nconst createEdge = (nodeA,nodeB)=>{\r\n    if(nodeA === null){\r\n        const xB = nodeB.centerX;\r\n        const yB = nodeB.centerY;\r\n        return {xB,yB,xB,yB};\r\n    }\r\n    const xA = nodeA.centerX;\r\n    const yA = nodeA.centerY;\r\n    const xB = nodeB.centerX;\r\n    const yB = nodeB.centerY;\r\n    const edge = {xA,yA,xB,yB};\r\n    return edge;\r\n}\r\n\r\nexport function bfs(graph, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    const visitedEdgesInOrder = [];\r\n    let bfsQueue = [startNode];\r\n    startNode.isVisited = true;\r\n\r\n    while (bfsQueue.length) {\r\n        const currentNode = bfsQueue.shift();\r\n        visitedNodesInOrder.push(currentNode);\r\n        visitedEdgesInOrder.push(createEdge(currentNode.parent, currentNode));\r\n        if (currentNode === finishNode) {\r\n            // console.log(visitedEdgesInOrder);\r\n            return { visitedNodesInOrder, visitedEdgesInOrder }\r\n        };\r\n        currentNode.children.forEach(childObject => {\r\n            const child = childObject.node;\r\n            if(!child.isVisited){\r\n                child.isVisited = true;\r\n                child.parent = currentNode;\r\n                // console.log(child);\r\n                bfsQueue.push(child);\r\n            }\r\n        });\r\n    }\r\n    return { visitedNodesInOrder, visitedEdgesInOrder };\r\n}","// DFS\r\nconst createEdge = (nodeA, nodeB) => {\r\n    const xA = nodeA.centerX;\r\n    const yA = nodeA.centerY;\r\n    const xB = nodeB.centerX;\r\n    const yB = nodeB.centerY;\r\n    const edge = { xA, yA, xB, yB };\r\n    return edge;\r\n}\r\n\r\nfunction getChildren(node) {\r\n    const childElements = [];\r\n\r\n    node.children.forEach((childObject) => {\r\n        const child = childObject.node;\r\n        if (!child.isVisited) {\r\n            childElements.push(child);\r\n        }\r\n    });\r\n\r\n    return childElements;\r\n}\r\n\r\nexport function dfs(graph, startNode, finishNode) {\r\n    const visitedNodesInOrder = [startNode];\r\n    const visitedEdgesInOrder = [];\r\n    startNode.isVisited = true;\r\n    let currentNode = startNode;\r\n    let dfsStack = [currentNode];\r\n    while (dfsStack.length) {\r\n        if (currentNode === finishNode) { \r\n            return { visitedNodesInOrder, visitedEdgesInOrder }; \r\n        }\r\n        const childElements = getChildren(currentNode);\r\n        if (childElements.length) {\r\n            childElements[0].parent = currentNode;\r\n            visitedEdgesInOrder.push(createEdge(currentNode, childElements[0]));\r\n            currentNode = childElements[0];\r\n            currentNode.isVisited = true;\r\n            visitedNodesInOrder.push(currentNode);\r\n            dfsStack.push(currentNode);\r\n        }\r\n        else {\r\n            dfsStack.pop();\r\n            currentNode = dfsStack[dfsStack.length - 1];\r\n        }\r\n    }\r\n    return { visitedNodesInOrder, visitedEdgesInOrder };\r\n}","// Dijkstra\r\n// still raw\r\n\r\nconst createEdge = (nodeA, nodeB) => {\r\n    const xA = nodeA.centerX;\r\n    const yA = nodeA.centerY;\r\n    const xB = nodeB.centerX;\r\n    const yB = nodeB.centerY;\r\n    const edge = { xA, yA, xB, yB };\r\n    return edge;\r\n}\r\n\r\nfunction getChildren(currentNode,visitedEdgesInOrder) {\r\n    const childNodes = [];\r\n    currentNode.children.forEach(childObject => {\r\n        const { node, weight } = childObject;\r\n        if (!node.isVisited) {\r\n            childNodes.push(node);\r\n            if (node.costFromSource > currentNode.costFromSource + weight) {\r\n                node.parent = currentNode;\r\n                visitedEdgesInOrder.push(createEdge(currentNode,node));\r\n            }\r\n            node.costFromSource = Math.min(node.costFromSource, currentNode.costFromSource + weight);\r\n        }\r\n        else if (node.isVisited) {\r\n            if (node.costFromSource > currentNode.costFromSource + weight) {\r\n                node.parent = currentNode;\r\n                visitedEdgesInOrder.push(createEdge(currentNode, node));\r\n            }\r\n            node.costFromSource = Math.min(node.costFromSource, currentNode.costFromSource + weight);\r\n        }\r\n    })\r\n    return childNodes;\r\n}\r\n\r\nfunction extractMinIndex(dijkstraPQ) {\r\n    let minNode = dijkstraPQ[0];\r\n    let minNodeIndex = 0;\r\n    for (let i = 1; i < dijkstraPQ.length; i++) {\r\n        let currentNode = dijkstraPQ[i];\r\n        if (minNode.costFromSource > currentNode.costFromSource) {\r\n            minNode = currentNode;\r\n            minNodeIndex = i;\r\n        }\r\n    }\r\n    return minNodeIndex;\r\n}\r\n\r\nexport function dijkstra(graph, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    const visitedEdgesInOrder = [];\r\n\r\n    let currentNode;\r\n    let dijkstraPQ = [startNode];\r\n    startNode.costFromSource = 0;\r\n    startNode.isVisited = true;\r\n    while (dijkstraPQ.length) {\r\n\r\n        const minIndex = extractMinIndex(dijkstraPQ);\r\n        currentNode = dijkstraPQ[minIndex];\r\n        if (currentNode === finishNode) {\r\n            visitedNodesInOrder.push(currentNode);\r\n            return { visitedNodesInOrder, visitedEdgesInOrder };\r\n        }\r\n\r\n        visitedNodesInOrder.push(currentNode);\r\n        const childNodes = getChildren(currentNode,visitedEdgesInOrder);\r\n        childNodes.forEach(node => {\r\n            dijkstraPQ.push(node);\r\n            node.isVisited = true;\r\n        });\r\n        dijkstraPQ.splice(minIndex, 1);\r\n    }\r\n    return {visitedNodesInOrder,visitedEdgesInOrder};\r\n}\r\n\r\n","const createEdge = (nodeA, nodeB) => {\r\n    const xA = nodeA.centerX;\r\n    const yA = nodeA.centerY;\r\n    const xB = nodeB.centerX;\r\n    const yB = nodeB.centerY;\r\n    const edge = { xA, yA, xB, yB };\r\n    return edge;\r\n}\r\n\r\nconst writeText = (info, style = {}) => {\r\n    const canvas = document.getElementById('canvas');\r\n    const ctx = canvas.getContext(\"2d\");\r\n    const { text, x, y } = info;\r\n    const { fontSize = 20, fontFamily = 'Arial', color = 'black', textAlign = 'left', textBaseline = 'top' } = style;\r\n\r\n    ctx.beginPath();\r\n    ctx.font = fontSize + 'px ' + fontFamily;\r\n    ctx.textAlign = textAlign;\r\n    ctx.textBaseline = textBaseline;\r\n    ctx.fillStyle = color;\r\n    ctx.fillText(text, x, y);\r\n    ctx.stroke();\r\n}\r\n\r\nexport function visitAllEdges(graph) {\r\n    let canvas = document.getElementById('canvas');\r\n    const ctx = canvas.getContext(\"2d\");\r\n    ctx.fillStyle = \"white\";\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n    graph.forEach((node) => {\r\n        node.isVisited = false;\r\n        node.parent = null;\r\n        node.costFromSource = Number.POSITIVE_INFINITY;\r\n    });\r\n\r\n    graph.forEach((node) => {\r\n        writeText({ text: `${node.id}`, x: node.centerX - 35, y: node.centerY - 35 });\r\n        if (!node.isVisited) {\r\n\r\n            ctx.strokeStyle = \"#000000\";\r\n            let { centerX, centerY } = node;\r\n            ctx.beginPath();\r\n            ctx.moveTo(centerX, centerY);\r\n            ctx.arc(centerX, centerY, 20, 0, Math.PI * 2, true);\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n\r\n            let bfsQueue = [node];\r\n            while (bfsQueue.length) {\r\n                const currentNode = bfsQueue.shift();\r\n                currentNode.isVisited = true;\r\n                currentNode.children.forEach(childObject => {\r\n                    const child = childObject.node;\r\n                    if (!child.isVisited) {\r\n                        const edge = createEdge(currentNode, child);\r\n                        const { xA, yA, xB, yB } = edge;\r\n                        const x = (xA + xB) / 2;\r\n                        const y = (yA + yB) / 2;\r\n                        const weight = (childObject.weight ? childObject.weight:'');\r\n                        writeText({text:weight,x,y});\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(xA, yA);\r\n                        ctx.lineTo(xB, yB);\r\n                        ctx.stroke();\r\n                        ctx.closePath();\r\n                        ctx.beginPath();\r\n                        ctx.arc(xB, yB, 20, 0, Math.PI * 2, false);\r\n                        ctx.stroke();\r\n                        ctx.closePath();\r\n                        bfsQueue.push(child);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n\r\n    graph.forEach((node) => {\r\n        node.isVisited = false;\r\n        node.parent = null;\r\n        node.costFromSource = Number.POSITIVE_INFINITY;\r\n    });\r\n}","import DisjointSet from '../../Data Structures/disjointSet';\r\n\r\nconst getEdgeWeight = (nodeA, nodeB) => {\r\n    for (let i = 0; i < nodeA.children.length; i++) {\r\n        const { node, weight } = nodeA.children[i];\r\n        if (node === nodeB) {\r\n            return weight;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nconst createEdge = (nodeA, nodeB) => {\r\n    const edgeWeight = getEdgeWeight(nodeA, nodeB);\r\n    const edge = { nodeA, nodeB, edgeWeight };\r\n    return edge;\r\n}\r\n\r\nfunction compare(edgeA, edgeB) {\r\n    return edgeA.edgeWeight - edgeB.edgeWeight;\r\n}\r\n\r\nexport function kruskalsMST(graph) {\r\n    let disjointSet = new DisjointSet((node) => {\r\n        return node.id;\r\n    });\r\n    graph.forEach((node) => {\r\n        node.isVisited = false;\r\n        node.parent = null;\r\n        node.costFromSource = Number.POSITIVE_INFINITY;\r\n        disjointSet.makeSet(node);\r\n    });\r\n    const graphEdges = [];\r\n    graph.forEach((node) => {\r\n        if (!node.isVisited) {\r\n            let bfsQueue = [node];\r\n            while (bfsQueue.length) {\r\n                const currentNode = bfsQueue.shift();\r\n                currentNode.isVisited = true;\r\n                currentNode.children.forEach(childObject => {\r\n                    const child = childObject.node;\r\n                    if (!child.isVisited) {\r\n                        const edge = createEdge(currentNode, child);\r\n                        graphEdges.push(edge);\r\n                        bfsQueue.push(child);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n    graphEdges.sort(compare);\r\n\r\n    const kruskalSelectedEdges = [];\r\n    graphEdges.forEach((edge) => {\r\n        const {nodeA,nodeB} = edge;\r\n        if(!disjointSet.inSameSet(nodeA,nodeB)){\r\n            kruskalSelectedEdges.push(edge);\r\n            disjointSet.union(nodeA,nodeB);\r\n        }\r\n    });\r\n\r\n    // graph.forEach((node) => {\r\n    //     node.isVisited = false;\r\n    //     node.parent = null;\r\n    //     node.costFromSource = Number.POSITIVE_INFINITY;\r\n    // });\r\n\r\n    return kruskalSelectedEdges;\r\n\r\n}","import DisjointSet from '../../Data Structures/disjointSet';\r\n\r\nconst getEdgeWeight = (nodeA, nodeB) => {\r\n    for (let i = 0; i < nodeA.children.length; i++) {\r\n        const { node, weight } = nodeA.children[i];\r\n        if (node === nodeB) {\r\n            return weight;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nconst createEdge = (nodeA, nodeB) => {\r\n    const edgeWeight = getEdgeWeight(nodeA, nodeB);\r\n    const edge = { nodeA, nodeB, edgeWeight };\r\n    return edge;\r\n}\r\n\r\nfunction compare(edgeA, edgeB) {\r\n    return edgeA.edgeWeight - edgeB.edgeWeight;\r\n}\r\n\r\nexport function primsMST(graph) {\r\n    let disjointSet = new DisjointSet((node) => {\r\n        return node.id;\r\n    });\r\n    graph.forEach((node) => {\r\n        node.isVisited = false;\r\n        node.parent = null;\r\n        node.costFromSource = Number.POSITIVE_INFINITY;\r\n        disjointSet.makeSet(node);\r\n    });\r\n    const primSelectedEdges = [];\r\n\r\n    let currentNode = graph[0];\r\n    const graphEdgesQueue = [];\r\n    for(let i=0;i<currentNode.children.length;i++){\r\n        const {node,weight} = currentNode.children[i];\r\n        graphEdgesQueue.push(createEdge(currentNode,node));\r\n    }\r\n    graphEdgesQueue.sort(compare);\r\n    \r\n    while(graphEdgesQueue.length){\r\n        const { nodeA, nodeB} = graphEdgesQueue[0];\r\n        if(!disjointSet.inSameSet(nodeA,nodeB)){\r\n            disjointSet.union(nodeA,nodeB);\r\n            currentNode = graphEdgesQueue[0].nodeB;\r\n            primSelectedEdges.push(graphEdgesQueue.shift());\r\n            for (let i = 0; i < currentNode.children.length; i++) {\r\n                const { node } = currentNode.children[i];\r\n                graphEdgesQueue.push(createEdge(currentNode, node));\r\n            }\r\n            graphEdgesQueue.sort(compare);\r\n        }\r\n        else graphEdgesQueue.shift();\r\n    }\r\n\r\n    return primSelectedEdges;\r\n}","import React, { useContext } from 'react';\r\nimport './Canvas.css';\r\nimport Navbar from '../Navbar';\r\nimport CanvasBoard from './CanvasBoard';\r\nimport { CanvasProvider } from './CanvasContext';\r\nimport { bfs } from './Algorithms/bfs';\r\nimport { dfs } from './Algorithms/dfs';\r\nimport { dijkstra } from './Algorithms/dijkstra';\r\nimport { visitAllEdges } from \"./Algorithms/visitAllEdges\";\r\nimport { kruskalsMST } from './Algorithms/kruskals';\r\nimport { primsMST } from './Algorithms/prims';\r\nlet nheight = 0;\r\nlet swidth = 0;\r\nclass Canvas extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            navbarHeight: 0,\r\n            height: 0,\r\n            width: 0,\r\n            graphOfNodes: [],\r\n            isRunning: false,\r\n            emptyGraphCall: false,\r\n            startNode: null,\r\n            endNode: null,\r\n        }\r\n    }\r\n\r\n    navbarHeight = (height) => {\r\n        nheight = height;\r\n    }\r\n    toggleEmptyTheGraph = () => {\r\n        const emptyGraphCall = !this.state.emptyGraphCall;\r\n        this.setState({ emptyGraphCall });\r\n    }\r\n    clearCanvas = () => {\r\n        this.setState({ emptyGraphCall: true });\r\n        const canvas = document.getElementById('canvas');\r\n        const context = canvas.getContext(\"2d\");\r\n        context.fillStyle = \"white\";\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n    }\r\n\r\n    settingStartNode = (startNode) => {\r\n        this.setState({ startNode });\r\n    }\r\n    settingEndNode = (endNode) => {\r\n        this.setState({ endNode });\r\n    }\r\n    settingGraph = (graphOfNodes) => {\r\n        this.setState({ graphOfNodes });\r\n    }\r\n\r\n    redrawGraph = () => {\r\n        const graphOfNodes = this.state.graphOfNodes;\r\n        visitAllEdges(graphOfNodes);\r\n    }\r\n\r\n    visualize(algo) {\r\n        if (!this.state.isRunning) {\r\n            const graphOfNodes = this.state.graphOfNodes;\r\n            if (!graphOfNodes.length) {\r\n                alert('Canvas is empty');\r\n                return;\r\n            }\r\n            this.setState({ isRunning: true });\r\n            this.redrawGraph();\r\n            let startNode = this.state.startNode, finishNode = this.state.endNode;\r\n\r\n            let visitedNodesInOrder1;\r\n            let visitedEdgesInOrder1;\r\n            switch (algo) {\r\n                case 'Dijkstra':\r\n                    {\r\n                        const { visitedNodesInOrder, visitedEdgesInOrder } = dijkstra(graphOfNodes, startNode, finishNode);\r\n                        visitedNodesInOrder1 = visitedNodesInOrder;\r\n                        visitedEdgesInOrder1 = visitedEdgesInOrder;\r\n                        break;\r\n                    }\r\n                case 'BFS':\r\n                    {\r\n                        const { visitedNodesInOrder, visitedEdgesInOrder } = bfs(graphOfNodes, startNode, finishNode);\r\n                        visitedNodesInOrder1 = visitedNodesInOrder;\r\n                        visitedEdgesInOrder1 = visitedEdgesInOrder;\r\n                        break;\r\n                    }\r\n                case 'DFS':\r\n                    {\r\n                        const { visitedNodesInOrder, visitedEdgesInOrder } = dfs(graphOfNodes, startNode, finishNode);\r\n                        visitedNodesInOrder1 = visitedNodesInOrder;\r\n                        visitedEdgesInOrder1 = visitedEdgesInOrder;\r\n                        break;\r\n                    }\r\n                default:\r\n                    // should never get here\r\n                    break;\r\n            }\r\n            visitedNodesInOrder1.forEach(node => {\r\n                console.log(node.id, node.costFromSource);\r\n            });\r\n            this.animate(visitedNodesInOrder1, visitedEdgesInOrder1, algo, finishNode);\r\n        }\r\n    }\r\n\r\n\r\n    animate = (visitedNodesInOrder, visitedEdgesInOrder, algo, finishNode) => {\r\n        let canvas = document.getElementById('canvas');\r\n        let ctx = canvas.getContext('2d');\r\n        ctx.fillStyle = \"green\";\r\n        ctx.strokeStyle = '#ff0000';\r\n        ctx.lineWidth = 1;\r\n\r\n        let { centerX, centerY } = visitedNodesInOrder[0];\r\n        ctx.beginPath();\r\n        ctx.moveTo(centerX, centerY);\r\n        ctx.arc(centerX, centerY, 20, 0, Math.PI * 2, false);\r\n        ctx.fill();\r\n        ctx.closePath();\r\n\r\n        for (let i = 0; i < visitedEdgesInOrder.length; i++) {\r\n            const { xA, yA, xB, yB } = visitedEdgesInOrder[i];\r\n\r\n            setTimeout(() => {\r\n                setTimeout(() => {\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(xA, yA);\r\n                    ctx.lineTo(xB, yB);\r\n                    ctx.stroke();\r\n                    ctx.closePath();\r\n                }, 500);\r\n\r\n                setTimeout(() => {\r\n                    ctx.beginPath();\r\n                    ctx.arc(xB, yB, 20, 0, Math.PI * 2, false);\r\n                    ctx.fill();\r\n                    ctx.closePath();\r\n                }, 1000);\r\n            }, i * 1000);\r\n\r\n        }\r\n        if (visitedNodesInOrder[visitedNodesInOrder.length - 1] === finishNode) {\r\n            setTimeout(() => {\r\n                this.animateShortestPath(finishNode, visitedNodesInOrder);\r\n            }, 1000 * (visitedEdgesInOrder.length + 1) + 100);\r\n        }\r\n        else {\r\n            setTimeout(() => {\r\n                ctx.fillStyle = \"#ffffff\";\r\n                ctx.strokeStyle = '#000000';\r\n                this.setState({ isRunning: false });\r\n                alert('node not reachable');\r\n            }, 1000 * visitedNodesInOrder.length + 100);\r\n        }\r\n\r\n    }\r\n    animateShortestPath = (endNode, visitedNodesInOrder) => {\r\n        let shortestPathNodes = [];\r\n        let currentNode = endNode;\r\n        while (currentNode) {\r\n            shortestPathNodes.push(currentNode);\r\n            currentNode = currentNode.parent;\r\n        }\r\n        let canvas = document.getElementById('canvas');\r\n        let ctx = canvas.getContext('2d');\r\n        ctx.fillStyle = \"yellow\";\r\n\r\n        for (let i = shortestPathNodes.length - 1; i >= 0; i--) {\r\n            setTimeout(() => {\r\n                const node = shortestPathNodes[i];\r\n                const { centerX, centerY } = node;\r\n                ctx.beginPath();\r\n                ctx.arc(centerX, centerY, 20, 0, Math.PI * 2, false);\r\n                ctx.fill();\r\n                ctx.closePath();\r\n            }, (shortestPathNodes.length - 1 - i) * 500);\r\n        }\r\n        setTimeout(() => {\r\n            ctx.fillStyle = \"#ffffff\";\r\n            ctx.strokeStyle = '#000000';\r\n            this.setState({ isRunning: false });\r\n            shortestPathNodes = [];\r\n        }, 500 * (shortestPathNodes.length) + 1000);\r\n    }\r\n\r\n    visualizeMST = (algo) => {\r\n        if (!this.state.isRunning) {\r\n            const graphOfNodes = this.state.graphOfNodes;\r\n            if (!graphOfNodes.length) {\r\n                alert('Canvas is empty');\r\n                return;\r\n            }\r\n            this.setState({ isRunning: true });\r\n            this.redrawGraph();\r\n            let MSTedges = [];\r\n            switch (algo) {\r\n                case 'Kruskal':\r\n                {\r\n                    MSTedges = kruskalsMST(graphOfNodes);\r\n                    console.log(MSTedges);\r\n                    break;\r\n                }\r\n                case 'Prims':\r\n                {\r\n                    MSTedges = primsMST(graphOfNodes);\r\n                    break;\r\n                }\r\n                default:\r\n                    // do nothing\r\n                    console.log(\"here\");\r\n                    break;\r\n            }\r\n            if(MSTedges.length) this.animateMST(MSTedges);\r\n            else{\r\n                this.setState({ isRunning: false });\r\n                console.log(\"ERROR\");\r\n            }\r\n        }\r\n    }\r\n    animateMST = (MSTedges) => {\r\n        let canvas = document.getElementById('canvas');\r\n        let ctx = canvas.getContext('2d');\r\n        ctx.strokeStyle = '#ff0000';\r\n        ctx.lineWidth = 5;\r\n\r\n        for(let i=0;i<MSTedges.length;i++){\r\n            setTimeout(()=>{\r\n                const { nodeA, nodeB } = MSTedges[i];\r\n                const xA = nodeA.centerX;\r\n                const yA = nodeA.centerY;\r\n                const xB = nodeB.centerX;\r\n                const yB = nodeB.centerY;\r\n                ctx.beginPath();\r\n                ctx.moveTo(xA, yA);\r\n                ctx.lineTo(xB, yB);\r\n                ctx.stroke();\r\n                ctx.closePath();\r\n            },i*500);\r\n        }\r\n        setTimeout(()=>{\r\n            ctx.strokeStyle = '#000000';\r\n            ctx.lineWidth = 1;\r\n            this.setState({isRunning:false});\r\n        },MSTedges.length*500+100);\r\n    }\r\n    toggleCanvas = () => {\r\n        const canvasOrGrid = !this.state.canvasOrGrid;\r\n        this.setState({ canvasOrGrid });\r\n        this.props.toggleCanvas();\r\n    }\r\n    componentWillMount = () => {\r\n        // console.log(\"required\",nheight,swidth);\r\n        // const height = document.documentElement.clientHeight - nheight;\r\n        // const width = document.documentElement.clientWidth - 100 - swidth;\r\n        // this.setState({ height, width });\r\n    }\r\n\r\n    render() {\r\n        const height = document.documentElement.clientHeight - nheight - 50;\r\n        const width = document.documentElement.clientWidth - swidth - 30;\r\n        return (\r\n            <div>\r\n                <CanvasProvider>\r\n                    <Navbar\r\n                        navbarHeight={this.navbarHeight}\r\n                        isCanvas={this.props.isCanvas}\r\n                        toggleCanvas={() => this.toggleCanvas()}\r\n                        bfs={() => this.visualize('BFS')}\r\n                        dfs={() => this.visualize('DFS')}\r\n                        dijkstra={() => this.visualize('Dijkstra')}\r\n                        clearGrid={() => this.redrawGraph()}\r\n                        resetGrid={() => this.clearCanvas()}\r\n                        kruskalMST={() => this.visualizeMST('Kruskal')}\r\n                        primMST={() => this.visualizeMST('Prims')}\r\n                    ></Navbar>\r\n                    <CanvasBoard\r\n                        height={height}\r\n                        width={width}\r\n                        settingGraph={this.settingGraph}\r\n                        settingStartNode={this.settingStartNode}\r\n                        settingEndNode={this.settingEndNode}\r\n                        emptyGraphCall={this.state.emptyGraphCall}\r\n                        toggleEmptyTheGraph={this.toggleEmptyTheGraph}\r\n                        isRunning={this.state.isRunning}\r\n                    ></CanvasBoard>\r\n                </CanvasProvider>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Canvas;","import React from 'react';\nimport './App.css';\n// import Navbar from './Navbar';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer'\nimport Canvas from './Canvas/Canvas'\n\nclass App extends React.Component{\n  constructor(props){\n    super(props);\n    this.state = {\n      canvas: false,\n    }\n  }\n\n  toggleCanvas = ()=>{\n    const canvas = !this.state.canvas;\n    this.setState({canvas});\n  }\n\n  render(){\n\n    if(!this.state.canvas){\n      return (\n        <div className=\"App\">\n          <PathfindingVisualizer\n              toggleCanvas={()=>this.toggleCanvas()}\n              isCanvas = {this.state.canvas}\n          ></PathfindingVisualizer>\n        </div>\n      )\n    }\n    else {\n      return (\n        <div className=\"App\">\n          <Canvas\n            toggleCanvas={() => this.toggleCanvas()}\n            isCanvas={this.state.canvas}\n          ></Canvas>\n        </div>\n      )\n    } \n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}